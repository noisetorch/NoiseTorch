// Code generated by build.go. DO NOT EDIT.

package gpu

import "gioui.org/gpu/internal/driver"

var (
	shader_backdrop_comp = driver.ShaderSources{
		Name:      "backdrop.comp",
		GLSL310ES: "#version 310 es\nlayout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;\n\nstruct Alloc\n{\n    uint offset;\n};\n\nstruct AnnotatedRef\n{\n    uint offset;\n};\n\nstruct AnnotatedTag\n{\n    uint tag;\n    uint flags;\n};\n\nstruct PathRef\n{\n    uint offset;\n};\n\nstruct TileRef\n{\n    uint offset;\n};\n\nstruct Path\n{\n    uvec4 bbox;\n    TileRef tiles;\n};\n\nstruct Config\n{\n    uint n_elements;\n    uint n_pathseg;\n    uint width_in_tiles;\n    uint height_in_tiles;\n    Alloc tile_alloc;\n    Alloc bin_alloc;\n    Alloc ptcl_alloc;\n    Alloc pathseg_alloc;\n    Alloc anno_alloc;\n    Alloc trans_alloc;\n};\n\nlayout(binding = 0, std430) buffer Memory\n{\n    uint mem_offset;\n    uint mem_error;\n    uint memory[];\n} _77;\n\nlayout(binding = 1, std430) readonly buffer ConfigBuf\n{\n    Config conf;\n} _191;\n\nshared uint sh_row_width[128];\nshared Alloc sh_row_alloc[128];\nshared uint sh_row_count[128];\n\nbool touch_mem(Alloc alloc, uint offset)\n{\n    return true;\n}\n\nuint read_mem(Alloc alloc, uint offset)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return 0u;\n    }\n    uint v = _77.memory[offset];\n    return v;\n}\n\nAnnotatedTag Annotated_tag(Alloc a, AnnotatedRef ref)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint tag_and_flags = read_mem(param, param_1);\n    return AnnotatedTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));\n}\n\nuint fill_mode_from_flags(uint flags)\n{\n    return flags & 1u;\n}\n\nPath Path_read(Alloc a, PathRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Path s;\n    s.bbox = uvec4(raw0 & 65535u, raw0 >> uint(16), raw1 & 65535u, raw1 >> uint(16));\n    s.tiles = TileRef(raw2);\n    return s;\n}\n\nAlloc new_alloc(uint offset, uint size)\n{\n    Alloc a;\n    a.offset = offset;\n    return a;\n}\n\nvoid write_mem(Alloc alloc, uint offset, uint val)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return;\n    }\n    _77.memory[offset] = val;\n}\n\nvoid main()\n{\n    if (_77.mem_error != 0u)\n    {\n        return;\n    }\n    uint th_ix = gl_LocalInvocationID.x;\n    uint element_ix = gl_GlobalInvocationID.x;\n    AnnotatedRef ref = AnnotatedRef(_191.conf.anno_alloc.offset + (element_ix * 32u));\n    uint row_count = 0u;\n    if (element_ix < _191.conf.n_elements)\n    {\n        Alloc param;\n        param.offset = _191.conf.anno_alloc.offset;\n        AnnotatedRef param_1 = ref;\n        AnnotatedTag tag = Annotated_tag(param, param_1);\n        switch (tag.tag)\n        {\n            case 2u:\n            case 3u:\n            case 1u:\n            {\n                uint param_2 = tag.flags;\n                if (fill_mode_from_flags(param_2) != 0u)\n                {\n                    break;\n                }\n                PathRef path_ref = PathRef(_191.conf.tile_alloc.offset + (element_ix * 12u));\n                Alloc param_3;\n                param_3.offset = _191.conf.tile_alloc.offset;\n                PathRef param_4 = path_ref;\n                Path path = Path_read(param_3, param_4);\n                sh_row_width[th_ix] = path.bbox.z - path.bbox.x;\n                row_count = path.bbox.w - path.bbox.y;\n                bool _267 = row_count == 1u;\n                bool _273;\n                if (_267)\n                {\n                    _273 = path.bbox.y > 0u;\n                }\n                else\n                {\n                    _273 = _267;\n                }\n                if (_273)\n                {\n                    row_count = 0u;\n                }\n                uint param_5 = path.tiles.offset;\n                uint param_6 = ((path.bbox.z - path.bbox.x) * (path.bbox.w - path.bbox.y)) * 8u;\n                Alloc path_alloc = new_alloc(param_5, param_6);\n                sh_row_alloc[th_ix] = path_alloc;\n                break;\n            }\n        }\n    }\n    sh_row_count[th_ix] = row_count;\n    for (uint i = 0u; i < 7u; i++)\n    {\n        barrier();\n        if (th_ix >= uint(1 << int(i)))\n        {\n            row_count += sh_row_count[th_ix - uint(1 << int(i))];\n        }\n        barrier();\n        sh_row_count[th_ix] = row_count;\n    }\n    barrier();\n    uint total_rows = sh_row_count[127];\n    uint _395;\n    for (uint row = th_ix; row < total_rows; row += 128u)\n    {\n        uint el_ix = 0u;\n        for (uint i_1 = 0u; i_1 < 7u; i_1++)\n        {\n            uint probe = el_ix + uint(64 >> int(i_1));\n            if (row >= sh_row_count[probe - 1u])\n            {\n                el_ix = probe;\n            }\n        }\n        uint width = sh_row_width[el_ix];\n        if (width > 0u)\n        {\n            Alloc tiles_alloc = sh_row_alloc[el_ix];\n            if (el_ix > 0u)\n            {\n                _395 = sh_row_count[el_ix - 1u];\n            }\n            else\n            {\n                _395 = 0u;\n            }\n            uint seq_ix = row - _395;\n            uint tile_el_ix = ((tiles_alloc.offset >> uint(2)) + 1u) + ((seq_ix * 2u) * width);\n            Alloc param_7 = tiles_alloc;\n            uint param_8 = tile_el_ix;\n            uint sum = read_mem(param_7, param_8);\n            for (uint x = 1u; x < width; x++)\n            {\n                tile_el_ix += 2u;\n                Alloc param_9 = tiles_alloc;\n                uint param_10 = tile_el_ix;\n                sum += read_mem(param_9, param_10);\n                Alloc param_11 = tiles_alloc;\n                uint param_12 = tile_el_ix;\n                uint param_13 = sum;\n                write_mem(param_11, param_12, param_13);\n            }\n        }\n    }\n}\n\n",
	}
	shader_binning_comp = driver.ShaderSources{
		Name:      "binning.comp",
		GLSL310ES: "#version 310 es\nlayout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;\n\nstruct Alloc\n{\n    uint offset;\n};\n\nstruct MallocResult\n{\n    Alloc alloc;\n    bool failed;\n};\n\nstruct AnnoEndClipRef\n{\n    uint offset;\n};\n\nstruct AnnoEndClip\n{\n    vec4 bbox;\n};\n\nstruct AnnotatedRef\n{\n    uint offset;\n};\n\nstruct AnnotatedTag\n{\n    uint tag;\n    uint flags;\n};\n\nstruct BinInstanceRef\n{\n    uint offset;\n};\n\nstruct BinInstance\n{\n    uint element_ix;\n};\n\nstruct Config\n{\n    uint n_elements;\n    uint n_pathseg;\n    uint width_in_tiles;\n    uint height_in_tiles;\n    Alloc tile_alloc;\n    Alloc bin_alloc;\n    Alloc ptcl_alloc;\n    Alloc pathseg_alloc;\n    Alloc anno_alloc;\n    Alloc trans_alloc;\n};\n\nlayout(binding = 0, std430) buffer Memory\n{\n    uint mem_offset;\n    uint mem_error;\n    uint memory[];\n} _88;\n\nlayout(binding = 1, std430) readonly buffer ConfigBuf\n{\n    Config conf;\n} _254;\n\nshared uint bitmaps[4][128];\nshared bool sh_alloc_failed;\nshared uint count[4][128];\nshared Alloc sh_chunk_alloc[128];\n\nbool touch_mem(Alloc alloc, uint offset)\n{\n    return true;\n}\n\nuint read_mem(Alloc alloc, uint offset)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return 0u;\n    }\n    uint v = _88.memory[offset];\n    return v;\n}\n\nAnnotatedTag Annotated_tag(Alloc a, AnnotatedRef ref)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint tag_and_flags = read_mem(param, param_1);\n    return AnnotatedTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));\n}\n\nAnnoEndClip AnnoEndClip_read(Alloc a, AnnoEndClipRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 3u;\n    uint raw3 = read_mem(param_6, param_7);\n    AnnoEndClip s;\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    return s;\n}\n\nAnnoEndClip Annotated_EndClip_read(Alloc a, AnnotatedRef ref)\n{\n    Alloc param = a;\n    AnnoEndClipRef param_1 = AnnoEndClipRef(ref.offset + 4u);\n    return AnnoEndClip_read(param, param_1);\n}\n\nAlloc new_alloc(uint offset, uint size)\n{\n    Alloc a;\n    a.offset = offset;\n    return a;\n}\n\nMallocResult malloc(uint size)\n{\n    MallocResult r;\n    r.failed = false;\n    uint _94 = atomicAdd(_88.mem_offset, size);\n    uint offset = _94;\n    uint param = offset;\n    uint param_1 = size;\n    r.alloc = new_alloc(param, param_1);\n    if ((offset + size) > uint(int(uint(_88.memory.length())) * 4))\n    {\n        r.failed = true;\n        uint _115 = atomicMax(_88.mem_error, 1u);\n        return r;\n    }\n    return r;\n}\n\nvoid write_mem(Alloc alloc, uint offset, uint val)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return;\n    }\n    _88.memory[offset] = val;\n}\n\nvoid BinInstance_write(Alloc a, BinInstanceRef ref, BinInstance s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = s.element_ix;\n    write_mem(param, param_1, param_2);\n}\n\nvoid main()\n{\n    if (_88.mem_error != 0u)\n    {\n        return;\n    }\n    uint my_n_elements = _254.conf.n_elements;\n    uint my_partition = gl_WorkGroupID.x;\n    for (uint i = 0u; i < 4u; i++)\n    {\n        bitmaps[i][gl_LocalInvocationID.x] = 0u;\n    }\n    if (gl_LocalInvocationID.x == 0u)\n    {\n        sh_alloc_failed = false;\n    }\n    barrier();\n    uint element_ix = (my_partition * 128u) + gl_LocalInvocationID.x;\n    AnnotatedRef ref = AnnotatedRef(_254.conf.anno_alloc.offset + (element_ix * 32u));\n    uint tag = 0u;\n    if (element_ix < my_n_elements)\n    {\n        Alloc param;\n        param.offset = _254.conf.anno_alloc.offset;\n        AnnotatedRef param_1 = ref;\n        tag = Annotated_tag(param, param_1).tag;\n    }\n    int x0 = 0;\n    int y0 = 0;\n    int x1 = 0;\n    int y1 = 0;\n    switch (tag)\n    {\n        case 1u:\n        case 2u:\n        case 3u:\n        case 4u:\n        {\n            Alloc param_2;\n            param_2.offset = _254.conf.anno_alloc.offset;\n            AnnotatedRef param_3 = ref;\n            AnnoEndClip clip = Annotated_EndClip_read(param_2, param_3);\n            x0 = int(floor(clip.bbox.x * 0.001953125));\n            y0 = int(floor(clip.bbox.y * 0.00390625));\n            x1 = int(ceil(clip.bbox.z * 0.001953125));\n            y1 = int(ceil(clip.bbox.w * 0.00390625));\n            break;\n        }\n    }\n    uint width_in_bins = ((_254.conf.width_in_tiles + 16u) - 1u) / 16u;\n    uint height_in_bins = ((_254.conf.height_in_tiles + 8u) - 1u) / 8u;\n    x0 = clamp(x0, 0, int(width_in_bins));\n    x1 = clamp(x1, x0, int(width_in_bins));\n    y0 = clamp(y0, 0, int(height_in_bins));\n    y1 = clamp(y1, y0, int(height_in_bins));\n    if (x0 == x1)\n    {\n        y1 = y0;\n    }\n    int x = x0;\n    int y = y0;\n    uint my_slice = gl_LocalInvocationID.x / 32u;\n    uint my_mask = uint(1 << int(gl_LocalInvocationID.x & 31u));\n    while (y < y1)\n    {\n        uint _438 = atomicOr(bitmaps[my_slice][(uint(y) * width_in_bins) + uint(x)], my_mask);\n        x++;\n        if (x == x1)\n        {\n            x = x0;\n            y++;\n        }\n    }\n    barrier();\n    uint element_count = 0u;\n    for (uint i_1 = 0u; i_1 < 4u; i_1++)\n    {\n        element_count += uint(bitCount(bitmaps[i_1][gl_LocalInvocationID.x]));\n        count[i_1][gl_LocalInvocationID.x] = element_count;\n    }\n    uint param_4 = 0u;\n    uint param_5 = 0u;\n    Alloc chunk_alloc = new_alloc(param_4, param_5);\n    if (element_count != 0u)\n    {\n        uint param_6 = element_count * 4u;\n        MallocResult _487 = malloc(param_6);\n        MallocResult chunk = _487;\n        chunk_alloc = chunk.alloc;\n        sh_chunk_alloc[gl_LocalInvocationID.x] = chunk_alloc;\n        if (chunk.failed)\n        {\n            sh_alloc_failed = true;\n        }\n    }\n    uint out_ix = (_254.conf.bin_alloc.offset >> uint(2)) + (((my_partition * 128u) + gl_LocalInvocationID.x) * 2u);\n    Alloc param_7;\n    param_7.offset = _254.conf.bin_alloc.offset;\n    uint param_8 = out_ix;\n    uint param_9 = element_count;\n    write_mem(param_7, param_8, param_9);\n    Alloc param_10;\n    param_10.offset = _254.conf.bin_alloc.offset;\n    uint param_11 = out_ix + 1u;\n    uint param_12 = chunk_alloc.offset;\n    write_mem(param_10, param_11, param_12);\n    barrier();\n    if (sh_alloc_failed)\n    {\n        return;\n    }\n    x = x0;\n    y = y0;\n    while (y < y1)\n    {\n        uint bin_ix = (uint(y) * width_in_bins) + uint(x);\n        uint out_mask = bitmaps[my_slice][bin_ix];\n        if ((out_mask & my_mask) != 0u)\n        {\n            uint idx = uint(bitCount(out_mask & (my_mask - 1u)));\n            if (my_slice > 0u)\n            {\n                idx += count[my_slice - 1u][bin_ix];\n            }\n            Alloc out_alloc = sh_chunk_alloc[bin_ix];\n            uint out_offset = out_alloc.offset + (idx * 4u);\n            Alloc param_13 = out_alloc;\n            BinInstanceRef param_14 = BinInstanceRef(out_offset);\n            BinInstance param_15 = BinInstance(element_ix);\n            BinInstance_write(param_13, param_14, param_15);\n        }\n        x++;\n        if (x == x1)\n        {\n            x = x0;\n            y++;\n        }\n    }\n}\n\n",
	}
	shader_blit_frag = [...]driver.ShaderSources{
		{
			Name: "blit.frag",
			Uniforms: driver.UniformsReflection{
				Blocks:    []driver.UniformBlock{{Name: "Color", Binding: 0}},
				Locations: []driver.UniformLocation{{Name: "_12._color", Type: 0x0, Size: 4, Offset: 0}},
				Size:      16,
			},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nvarying vec2 vUV;\n\nvoid main()\n{\n    gl_FragData[0] = _12._color;\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nlayout(std140) uniform Color\n{\n    vec4 _color;\n} _12;\n\nlayout(location = 0) out vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n}\n\n",
			GLSL130:   "#version 130\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n}\n\n",
			GLSL150:   "#version 150\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n}\n\n",
			HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0xc6, 0x4a, 0x23, 0x81, 0x87, 0xab, 0xe3, 0xca, 0x12, 0x9, 0x7e, 0x2f, 0x5e, 0x2, 0x62, 0x14, 0x1, 0x0, 0x0, 0x0, 0x70, 0x2, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x84, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x48, 0x1, 0x0, 0x0, 0x8, 0x2, 0x0, 0x0, 0x3c, 0x2, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x44, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x14, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x40, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x6, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xb8, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x0, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x74, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x0, 0xab, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
		{
			Name: "blit.frag",
			Uniforms: driver.UniformsReflection{
				Blocks:    []driver.UniformBlock{{Name: "Gradient", Binding: 0}},
				Locations: []driver.UniformLocation{{Name: "_12._color1", Type: 0x0, Size: 4, Offset: 0}, {Name: "_12._color2", Type: 0x0, Size: 4, Offset: 16}},
				Size:      32,
			},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nvarying vec2 vUV;\n\nvoid main()\n{\n    gl_FragData[0] = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nlayout(std140) uniform Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n} _12;\n\nlayout(location = 0) out vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n}\n\n",
			GLSL130:   "#version 130\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n}\n\n",
			GLSL150:   "#version 150\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n}\n\n",
			HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0xc0, 0x43, 0x72, 0x3d, 0x68, 0xc9, 0x38, 0x57, 0x9f, 0xa3, 0x60, 0xa8, 0xae, 0xd2, 0xa2, 0xf0, 0x1, 0x0, 0x0, 0x0, 0x40, 0x3, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x74, 0x1, 0x0, 0x0, 0xf0, 0x1, 0x0, 0x0, 0xd8, 0x2, 0x0, 0x0, 0xc, 0x3, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x8c, 0x0, 0x0, 0x0, 0x8c, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x5c, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x3, 0xb0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x18, 0x80, 0x0, 0x0, 0x0, 0xb0, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0xf, 0x80, 0x1, 0x0, 0xe4, 0x81, 0x1, 0x0, 0xe4, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xff, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0xa0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x12, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x36, 0x20, 0x0, 0x5, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xf2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xa, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xe0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x48, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0xb7, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x47, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x0, 0xab, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xac, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x31, 0x0, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x32, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x1, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
		{
			Name:      "blit.frag",
			Textures:  []driver.TextureBinding{{Name: "tex", Binding: 0}},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\n\nvarying vec2 vUV;\n\nvoid main()\n{\n    gl_FragData[0] = texture2D(tex, vUV);\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\n\nlayout(location = 0) out vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n}\n\n",
			GLSL130:   "#version 130\n\nuniform sampler2D tex;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n}\n\n",
			GLSL150:   "#version 150\n\nuniform sampler2D tex;\n\nout vec4 fragColor;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n}\n\n",
			HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0xb7, 0x3f, 0x1d, 0xb1, 0x80, 0xcd, 0x80, 0xa3, 0x57, 0x9, 0xfb, 0x5a, 0x9f, 0x56, 0xd6, 0xda, 0x1, 0x0, 0x0, 0x0, 0x94, 0x2, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xa4, 0x0, 0x0, 0x0, 0x10, 0x1, 0x0, 0x0, 0x8c, 0x1, 0x0, 0x0, 0x2c, 0x2, 0x0, 0x0, 0x60, 0x2, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x64, 0x0, 0x0, 0x0, 0x64, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x3c, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x28, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x3, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x0, 0x8, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x64, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x98, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x6d, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x69, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x5f, 0x74, 0x65, 0x78, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x74, 0x65, 0x78, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
	}
	shader_blit_vert = driver.ShaderSources{
		Name:   "blit.vert",
		Inputs: []driver.InputLocation{{Name: "pos", Location: 0, Semantic: "POSITION", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "NORMAL", SemanticIndex: 0, Type: 0x0, Size: 2}},
		Uniforms: driver.UniformsReflection{
			Blocks:    []driver.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []driver.UniformLocation{{Name: "_52.transform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_52.uvTransformR1", Type: 0x0, Size: 4, Offset: 16}, {Name: "_52.uvTransformR2", Type: 0x0, Size: 4, Offset: 32}, {Name: "_52.z", Type: 0x0, Size: 1, Offset: 48}},
			Size:      52,
		},
		GLSL100ES: "\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _52;\n\nattribute vec2 pos;\nvarying vec2 vUV;\nattribute vec2 uv;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec2 p = (pos * _52.transform.xy) + _52.transform.zw;\n    vec4 param = vec4(p, _52.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_52.uvTransformR1.xyz, _52.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n}\n\n",
		GLSL300ES: "#version 300 es\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nlayout(std140) uniform Block\n{\n    vec4 transform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n} _52;\n\nlayout(location = 0) in vec2 pos;\nout vec2 vUV;\nlayout(location = 1) in vec2 uv;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec2 p = (pos * _52.transform.xy) + _52.transform.zw;\n    vec4 param = vec4(p, _52.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_52.uvTransformR1.xyz, _52.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n}\n\n",
		GLSL130:   "#version 130\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _52;\n\nin vec2 pos;\nout vec2 vUV;\nin vec2 uv;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec2 p = (pos * _52.transform.xy) + _52.transform.zw;\n    vec4 param = vec4(p, _52.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_52.uvTransformR1.xyz, _52.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n}\n\n",
		GLSL150:   "#version 150\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _52;\n\nin vec2 pos;\nout vec2 vUV;\nin vec2 uv;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec2 p = (pos * _52.transform.xy) + _52.transform.zw;\n    vec4 param = vec4(p, _52.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_52.uvTransformR1.xyz, _52.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n}\n\n",
		HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0x57, 0x0, 0x34, 0xa, 0xf6, 0x3b, 0x1b, 0xc4, 0x28, 0xa1, 0x26, 0x75, 0x95, 0x95, 0xc4, 0x27, 0x1, 0x0, 0x0, 0x0, 0xc0, 0x4, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x24, 0x1, 0x0, 0x0, 0x54, 0x2, 0x0, 0x0, 0xd0, 0x2, 0x0, 0x0, 0x18, 0x4, 0x0, 0x0, 0x68, 0x4, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0xe4, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0xb0, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x1, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x51, 0x0, 0x0, 0x5, 0x5, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x1, 0x80, 0x1, 0x0, 0xf, 0x90, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x7, 0x80, 0x1, 0x0, 0xc4, 0x90, 0x5, 0x0, 0xd0, 0xa0, 0x5, 0x0, 0xc5, 0xa0, 0x8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0xe0, 0x2, 0x0, 0xe4, 0xa0, 0x0, 0x0, 0xe4, 0x80, 0x8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0xe0, 0x3, 0x0, 0xe4, 0xa0, 0x0, 0x0, 0xe4, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x90, 0x1, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0xee, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0xc0, 0x0, 0x0, 0xe4, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x7, 0x80, 0x5, 0x0, 0xe4, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0xc, 0xc0, 0x4, 0x0, 0x0, 0xa0, 0x0, 0x0, 0x64, 0x80, 0x0, 0x0, 0x24, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x28, 0x1, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x4a, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x32, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x10, 0x0, 0x0, 0x8, 0x12, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x82, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x8, 0x22, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x82, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xa, 0x42, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x36, 0x0, 0x0, 0x5, 0x82, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x40, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0x18, 0x1, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x0, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xdc, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x36, 0x39, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0xab, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x36, 0x39, 0x5f, 0x75, 0x76, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x52, 0x31, 0x0, 0x5f, 0x36, 0x39, 0x5f, 0x75, 0x76, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x52, 0x32, 0x0, 0x5f, 0x36, 0x39, 0x5f, 0x7a, 0x0, 0xab, 0xab, 0x0, 0x0, 0x3, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x48, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x50, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0xab, 0xab, 0xab},
	}
	shader_coarse_comp = driver.ShaderSources{
		Name:      "coarse.comp",
		GLSL310ES: "#version 310 es\nlayout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;\n\nstruct Alloc\n{\n    uint offset;\n};\n\nstruct MallocResult\n{\n    Alloc alloc;\n    bool failed;\n};\n\nstruct AnnoImageRef\n{\n    uint offset;\n};\n\nstruct AnnoImage\n{\n    vec4 bbox;\n    float linewidth;\n    uint index;\n    ivec2 offset;\n};\n\nstruct AnnoColorRef\n{\n    uint offset;\n};\n\nstruct AnnoColor\n{\n    vec4 bbox;\n    float linewidth;\n    uint rgba_color;\n};\n\nstruct AnnoBeginClipRef\n{\n    uint offset;\n};\n\nstruct AnnoBeginClip\n{\n    vec4 bbox;\n    float linewidth;\n};\n\nstruct AnnotatedRef\n{\n    uint offset;\n};\n\nstruct AnnotatedTag\n{\n    uint tag;\n    uint flags;\n};\n\nstruct BinInstanceRef\n{\n    uint offset;\n};\n\nstruct BinInstance\n{\n    uint element_ix;\n};\n\nstruct PathRef\n{\n    uint offset;\n};\n\nstruct TileRef\n{\n    uint offset;\n};\n\nstruct Path\n{\n    uvec4 bbox;\n    TileRef tiles;\n};\n\nstruct TileSegRef\n{\n    uint offset;\n};\n\nstruct Tile\n{\n    TileSegRef tile;\n    int backdrop;\n};\n\nstruct CmdStrokeRef\n{\n    uint offset;\n};\n\nstruct CmdStroke\n{\n    uint tile_ref;\n    float half_width;\n};\n\nstruct CmdFillRef\n{\n    uint offset;\n};\n\nstruct CmdFill\n{\n    uint tile_ref;\n    int backdrop;\n};\n\nstruct CmdColorRef\n{\n    uint offset;\n};\n\nstruct CmdColor\n{\n    uint rgba_color;\n};\n\nstruct CmdImageRef\n{\n    uint offset;\n};\n\nstruct CmdImage\n{\n    uint index;\n    ivec2 offset;\n};\n\nstruct CmdJumpRef\n{\n    uint offset;\n};\n\nstruct CmdJump\n{\n    uint new_ref;\n};\n\nstruct CmdRef\n{\n    uint offset;\n};\n\nstruct Config\n{\n    uint n_elements;\n    uint n_pathseg;\n    uint width_in_tiles;\n    uint height_in_tiles;\n    Alloc tile_alloc;\n    Alloc bin_alloc;\n    Alloc ptcl_alloc;\n    Alloc pathseg_alloc;\n    Alloc anno_alloc;\n    Alloc trans_alloc;\n};\n\nlayout(binding = 0, std430) buffer Memory\n{\n    uint mem_offset;\n    uint mem_error;\n    uint memory[];\n} _276;\n\nlayout(binding = 1, std430) readonly buffer ConfigBuf\n{\n    Config conf;\n} _1066;\n\nshared uint sh_bitmaps[4][128];\nshared Alloc sh_part_elements[128];\nshared uint sh_part_count[128];\nshared uint sh_elements[128];\nshared uint sh_tile_stride[128];\nshared uint sh_tile_width[128];\nshared uint sh_tile_x0[128];\nshared uint sh_tile_y0[128];\nshared uint sh_tile_base[128];\nshared uint sh_tile_count[128];\n\nAlloc new_alloc(uint offset, uint size)\n{\n    Alloc a;\n    a.offset = offset;\n    return a;\n}\n\nAlloc slice_mem(Alloc a, uint offset, uint size)\n{\n    uint param = a.offset + offset;\n    uint param_1 = size;\n    return new_alloc(param, param_1);\n}\n\nbool touch_mem(Alloc alloc, uint offset)\n{\n    return true;\n}\n\nuint read_mem(Alloc alloc, uint offset)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return 0u;\n    }\n    uint v = _276.memory[offset];\n    return v;\n}\n\nBinInstanceRef BinInstance_index(BinInstanceRef ref, uint index)\n{\n    return BinInstanceRef(ref.offset + (index * 4u));\n}\n\nBinInstance BinInstance_read(Alloc a, BinInstanceRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    BinInstance s;\n    s.element_ix = raw0;\n    return s;\n}\n\nAnnotatedTag Annotated_tag(Alloc a, AnnotatedRef ref)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint tag_and_flags = read_mem(param, param_1);\n    return AnnotatedTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));\n}\n\nPath Path_read(Alloc a, PathRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Path s;\n    s.bbox = uvec4(raw0 & 65535u, raw0 >> uint(16), raw1 & 65535u, raw1 >> uint(16));\n    s.tiles = TileRef(raw2);\n    return s;\n}\n\nvoid write_tile_alloc(uint el_ix, Alloc a)\n{\n}\n\nAlloc read_tile_alloc(uint el_ix)\n{\n    uint param = 0u;\n    uint param_1 = uint(int(uint(_276.memory.length())) * 4);\n    return new_alloc(param, param_1);\n}\n\nTile Tile_read(Alloc a, TileRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Tile s;\n    s.tile = TileSegRef(raw0);\n    s.backdrop = int(raw1);\n    return s;\n}\n\nAnnoColor AnnoColor_read(Alloc a, AnnoColorRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 3u;\n    uint raw3 = read_mem(param_6, param_7);\n    Alloc param_8 = a;\n    uint param_9 = ix + 4u;\n    uint raw4 = read_mem(param_8, param_9);\n    Alloc param_10 = a;\n    uint param_11 = ix + 5u;\n    uint raw5 = read_mem(param_10, param_11);\n    AnnoColor s;\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    s.linewidth = uintBitsToFloat(raw4);\n    s.rgba_color = raw5;\n    return s;\n}\n\nAnnoColor Annotated_Color_read(Alloc a, AnnotatedRef ref)\n{\n    Alloc param = a;\n    AnnoColorRef param_1 = AnnoColorRef(ref.offset + 4u);\n    return AnnoColor_read(param, param_1);\n}\n\nMallocResult malloc(uint size)\n{\n    MallocResult r;\n    r.failed = false;\n    uint _282 = atomicAdd(_276.mem_offset, size);\n    uint offset = _282;\n    uint param = offset;\n    uint param_1 = size;\n    r.alloc = new_alloc(param, param_1);\n    if ((offset + size) > uint(int(uint(_276.memory.length())) * 4))\n    {\n        r.failed = true;\n        uint _303 = atomicMax(_276.mem_error, 1u);\n        return r;\n    }\n    return r;\n}\n\nvoid write_mem(Alloc alloc, uint offset, uint val)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return;\n    }\n    _276.memory[offset] = val;\n}\n\nvoid CmdJump_write(Alloc a, CmdJumpRef ref, CmdJump s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = s.new_ref;\n    write_mem(param, param_1, param_2);\n}\n\nvoid Cmd_Jump_write(Alloc a, CmdRef ref, CmdJump s)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = 9u;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    CmdJumpRef param_4 = CmdJumpRef(ref.offset + 4u);\n    CmdJump param_5 = s;\n    CmdJump_write(param_3, param_4, param_5);\n}\n\nbool alloc_cmd(inout Alloc cmd_alloc, inout CmdRef cmd_ref, inout uint cmd_limit)\n{\n    if (cmd_ref.offset < cmd_limit)\n    {\n        return true;\n    }\n    uint param = 1024u;\n    MallocResult _968 = malloc(param);\n    MallocResult new_cmd = _968;\n    if (new_cmd.failed)\n    {\n        return false;\n    }\n    CmdJump jump = CmdJump(new_cmd.alloc.offset);\n    Alloc param_1 = cmd_alloc;\n    CmdRef param_2 = cmd_ref;\n    CmdJump param_3 = jump;\n    Cmd_Jump_write(param_1, param_2, param_3);\n    cmd_alloc = new_cmd.alloc;\n    cmd_ref = CmdRef(cmd_alloc.offset);\n    cmd_limit = (cmd_alloc.offset + 1024u) - 36u;\n    return true;\n}\n\nuint fill_mode_from_flags(uint flags)\n{\n    return flags & 1u;\n}\n\nvoid CmdFill_write(Alloc a, CmdFillRef ref, CmdFill s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = s.tile_ref;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = uint(s.backdrop);\n    write_mem(param_3, param_4, param_5);\n}\n\nvoid Cmd_Fill_write(Alloc a, CmdRef ref, CmdFill s)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = 1u;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    CmdFillRef param_4 = CmdFillRef(ref.offset + 4u);\n    CmdFill param_5 = s;\n    CmdFill_write(param_3, param_4, param_5);\n}\n\nvoid Cmd_Solid_write(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = 3u;\n    write_mem(param, param_1, param_2);\n}\n\nvoid CmdStroke_write(Alloc a, CmdStrokeRef ref, CmdStroke s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = s.tile_ref;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = floatBitsToUint(s.half_width);\n    write_mem(param_3, param_4, param_5);\n}\n\nvoid Cmd_Stroke_write(Alloc a, CmdRef ref, CmdStroke s)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = 2u;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    CmdStrokeRef param_4 = CmdStrokeRef(ref.offset + 4u);\n    CmdStroke param_5 = s;\n    CmdStroke_write(param_3, param_4, param_5);\n}\n\nvoid write_fill(Alloc alloc, inout CmdRef cmd_ref, uint flags, Tile tile, float linewidth)\n{\n    uint param = flags;\n    if (fill_mode_from_flags(param) == 0u)\n    {\n        if (tile.tile.offset != 0u)\n        {\n            CmdFill cmd_fill = CmdFill(tile.tile.offset, tile.backdrop);\n            Alloc param_1 = alloc;\n            CmdRef param_2 = cmd_ref;\n            CmdFill param_3 = cmd_fill;\n            Cmd_Fill_write(param_1, param_2, param_3);\n            cmd_ref.offset += 12u;\n        }\n        else\n        {\n            Alloc param_4 = alloc;\n            CmdRef param_5 = cmd_ref;\n            Cmd_Solid_write(param_4, param_5);\n            cmd_ref.offset += 4u;\n        }\n    }\n    else\n    {\n        CmdStroke cmd_stroke = CmdStroke(tile.tile.offset, 0.5 * linewidth);\n        Alloc param_6 = alloc;\n        CmdRef param_7 = cmd_ref;\n        CmdStroke param_8 = cmd_stroke;\n        Cmd_Stroke_write(param_6, param_7, param_8);\n        cmd_ref.offset += 12u;\n    }\n}\n\nvoid CmdColor_write(Alloc a, CmdColorRef ref, CmdColor s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = s.rgba_color;\n    write_mem(param, param_1, param_2);\n}\n\nvoid Cmd_Color_write(Alloc a, CmdRef ref, CmdColor s)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = 5u;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    CmdColorRef param_4 = CmdColorRef(ref.offset + 4u);\n    CmdColor param_5 = s;\n    CmdColor_write(param_3, param_4, param_5);\n}\n\nAnnoImage AnnoImage_read(Alloc a, AnnoImageRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 3u;\n    uint raw3 = read_mem(param_6, param_7);\n    Alloc param_8 = a;\n    uint param_9 = ix + 4u;\n    uint raw4 = read_mem(param_8, param_9);\n    Alloc param_10 = a;\n    uint param_11 = ix + 5u;\n    uint raw5 = read_mem(param_10, param_11);\n    Alloc param_12 = a;\n    uint param_13 = ix + 6u;\n    uint raw6 = read_mem(param_12, param_13);\n    AnnoImage s;\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    s.linewidth = uintBitsToFloat(raw4);\n    s.index = raw5;\n    s.offset = ivec2(int(raw6 << uint(16)) >> 16, int(raw6) >> 16);\n    return s;\n}\n\nAnnoImage Annotated_Image_read(Alloc a, AnnotatedRef ref)\n{\n    Alloc param = a;\n    AnnoImageRef param_1 = AnnoImageRef(ref.offset + 4u);\n    return AnnoImage_read(param, param_1);\n}\n\nvoid CmdImage_write(Alloc a, CmdImageRef ref, CmdImage s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = s.index;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = (uint(s.offset.x) & 65535u) | (uint(s.offset.y) << uint(16));\n    write_mem(param_3, param_4, param_5);\n}\n\nvoid Cmd_Image_write(Alloc a, CmdRef ref, CmdImage s)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = 6u;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    CmdImageRef param_4 = CmdImageRef(ref.offset + 4u);\n    CmdImage param_5 = s;\n    CmdImage_write(param_3, param_4, param_5);\n}\n\nAnnoBeginClip AnnoBeginClip_read(Alloc a, AnnoBeginClipRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 3u;\n    uint raw3 = read_mem(param_6, param_7);\n    Alloc param_8 = a;\n    uint param_9 = ix + 4u;\n    uint raw4 = read_mem(param_8, param_9);\n    AnnoBeginClip s;\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    s.linewidth = uintBitsToFloat(raw4);\n    return s;\n}\n\nAnnoBeginClip Annotated_BeginClip_read(Alloc a, AnnotatedRef ref)\n{\n    Alloc param = a;\n    AnnoBeginClipRef param_1 = AnnoBeginClipRef(ref.offset + 4u);\n    return AnnoBeginClip_read(param, param_1);\n}\n\nvoid Cmd_BeginClip_write(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = 7u;\n    write_mem(param, param_1, param_2);\n}\n\nvoid Cmd_EndClip_write(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = 8u;\n    write_mem(param, param_1, param_2);\n}\n\nvoid Cmd_End_write(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = 0u;\n    write_mem(param, param_1, param_2);\n}\n\nvoid alloc_write(Alloc a, uint offset, Alloc alloc)\n{\n    Alloc param = a;\n    uint param_1 = offset >> uint(2);\n    uint param_2 = alloc.offset;\n    write_mem(param, param_1, param_2);\n}\n\nvoid main()\n{\n    if (_276.mem_error != 0u)\n    {\n        return;\n    }\n    uint width_in_bins = ((_1066.conf.width_in_tiles + 16u) - 1u) / 16u;\n    uint bin_ix = (width_in_bins * gl_WorkGroupID.y) + gl_WorkGroupID.x;\n    uint partition_ix = 0u;\n    uint n_partitions = ((_1066.conf.n_elements + 128u) - 1u) / 128u;\n    uint th_ix = gl_LocalInvocationID.x;\n    uint bin_tile_x = 16u * gl_WorkGroupID.x;\n    uint bin_tile_y = 8u * gl_WorkGroupID.y;\n    uint tile_x = gl_LocalInvocationID.x % 16u;\n    uint tile_y = gl_LocalInvocationID.x / 16u;\n    uint this_tile_ix = (((bin_tile_y + tile_y) * _1066.conf.width_in_tiles) + bin_tile_x) + tile_x;\n    Alloc param;\n    param.offset = _1066.conf.ptcl_alloc.offset;\n    uint param_1 = this_tile_ix * 1024u;\n    uint param_2 = 1024u;\n    Alloc cmd_alloc = slice_mem(param, param_1, param_2);\n    CmdRef cmd_ref = CmdRef(cmd_alloc.offset);\n    uint cmd_limit = (cmd_ref.offset + 1024u) - 36u;\n    uint clip_depth = 0u;\n    uint clip_zero_depth = 0u;\n    uint clip_one_mask = 0u;\n    uint rd_ix = 0u;\n    uint wr_ix = 0u;\n    uint part_start_ix = 0u;\n    uint ready_ix = 0u;\n    Alloc param_3 = cmd_alloc;\n    uint param_4 = 0u;\n    uint param_5 = 8u;\n    Alloc scratch_alloc = slice_mem(param_3, param_4, param_5);\n    cmd_ref.offset += 8u;\n    uint num_begin_slots = 0u;\n    uint begin_slot = 0u;\n    Alloc param_6;\n    Alloc param_8;\n    uint _1354;\n    uint element_ix;\n    AnnotatedRef ref;\n    Alloc param_16;\n    Alloc param_18;\n    uint tile_count;\n    Alloc param_24;\n    uint _1667;\n    bool include_tile;\n    Alloc param_29;\n    Tile tile_1;\n    Alloc param_34;\n    Alloc param_50;\n    Alloc param_66;\n    while (true)\n    {\n        for (uint i = 0u; i < 4u; i++)\n        {\n            sh_bitmaps[i][th_ix] = 0u;\n        }\n        bool _1406;\n        for (;;)\n        {\n            if ((ready_ix == wr_ix) && (partition_ix < n_partitions))\n            {\n                part_start_ix = ready_ix;\n                uint count = 0u;\n                bool _1204 = th_ix < 128u;\n                bool _1212;\n                if (_1204)\n                {\n                    _1212 = (partition_ix + th_ix) < n_partitions;\n                }\n                else\n                {\n                    _1212 = _1204;\n                }\n                if (_1212)\n                {\n                    uint in_ix = (_1066.conf.bin_alloc.offset >> uint(2)) + ((((partition_ix + th_ix) * 128u) + bin_ix) * 2u);\n                    param_6.offset = _1066.conf.bin_alloc.offset;\n                    uint param_7 = in_ix;\n                    count = read_mem(param_6, param_7);\n                    param_8.offset = _1066.conf.bin_alloc.offset;\n                    uint param_9 = in_ix + 1u;\n                    uint offset = read_mem(param_8, param_9);\n                    uint param_10 = offset;\n                    uint param_11 = count * 4u;\n                    sh_part_elements[th_ix] = new_alloc(param_10, param_11);\n                }\n                for (uint i_1 = 0u; i_1 < 7u; i_1++)\n                {\n                    if (th_ix < 128u)\n                    {\n                        sh_part_count[th_ix] = count;\n                    }\n                    barrier();\n                    if (th_ix < 128u)\n                    {\n                        if (th_ix >= uint(1 << int(i_1)))\n                        {\n                            count += sh_part_count[th_ix - uint(1 << int(i_1))];\n                        }\n                    }\n                    barrier();\n                }\n                if (th_ix < 128u)\n                {\n                    sh_part_count[th_ix] = part_start_ix + count;\n                }\n                barrier();\n                ready_ix = sh_part_count[127];\n                partition_ix += 128u;\n            }\n            uint ix = rd_ix + th_ix;\n            if ((ix >= wr_ix) && (ix < ready_ix))\n            {\n                uint part_ix = 0u;\n                for (uint i_2 = 0u; i_2 < 7u; i_2++)\n                {\n                    uint probe = part_ix + uint(64 >> int(i_2));\n                    if (ix >= sh_part_count[probe - 1u])\n                    {\n                        part_ix = probe;\n                    }\n                }\n                if (part_ix > 0u)\n                {\n                    _1354 = sh_part_count[part_ix - 1u];\n                }\n                else\n                {\n                    _1354 = part_start_ix;\n                }\n                ix -= _1354;\n                Alloc bin_alloc = sh_part_elements[part_ix];\n                BinInstanceRef inst_ref = BinInstanceRef(bin_alloc.offset);\n                BinInstanceRef param_12 = inst_ref;\n                uint param_13 = ix;\n                Alloc param_14 = bin_alloc;\n                BinInstanceRef param_15 = BinInstance_index(param_12, param_13);\n                BinInstance inst = BinInstance_read(param_14, param_15);\n                sh_elements[th_ix] = inst.element_ix;\n            }\n            barrier();\n            wr_ix = min((rd_ix + 128u), ready_ix);\n            bool _1396 = (wr_ix - rd_ix) < 128u;\n            if (_1396)\n            {\n                _1406 = (wr_ix < ready_ix) || (partition_ix < n_partitions);\n            }\n            else\n            {\n                _1406 = _1396;\n            }\n            if (_1406)\n            {\n                continue;\n            }\n            else\n            {\n                break;\n            }\n        }\n        uint tag = 0u;\n        if ((th_ix + rd_ix) < wr_ix)\n        {\n            element_ix = sh_elements[th_ix];\n            ref = AnnotatedRef(_1066.conf.anno_alloc.offset + (element_ix * 32u));\n            param_16.offset = _1066.conf.anno_alloc.offset;\n            AnnotatedRef param_17 = ref;\n            tag = Annotated_tag(param_16, param_17).tag;\n        }\n        switch (tag)\n        {\n            case 1u:\n            case 2u:\n            case 3u:\n            case 4u:\n            {\n                uint path_ix = element_ix;\n                param_18.offset = _1066.conf.tile_alloc.offset;\n                PathRef param_19 = PathRef(_1066.conf.tile_alloc.offset + (path_ix * 12u));\n                Path path = Path_read(param_18, param_19);\n                uint stride = path.bbox.z - path.bbox.x;\n                sh_tile_stride[th_ix] = stride;\n                int dx = int(path.bbox.x) - int(bin_tile_x);\n                int dy = int(path.bbox.y) - int(bin_tile_y);\n                int x0 = clamp(dx, 0, 16);\n                int y0 = clamp(dy, 0, 8);\n                int x1 = clamp(int(path.bbox.z) - int(bin_tile_x), 0, 16);\n                int y1 = clamp(int(path.bbox.w) - int(bin_tile_y), 0, 8);\n                sh_tile_width[th_ix] = uint(x1 - x0);\n                sh_tile_x0[th_ix] = uint(x0);\n                sh_tile_y0[th_ix] = uint(y0);\n                tile_count = uint(x1 - x0) * uint(y1 - y0);\n                uint base = path.tiles.offset - (((uint(dy) * stride) + uint(dx)) * 8u);\n                sh_tile_base[th_ix] = base;\n                uint param_20 = path.tiles.offset;\n                uint param_21 = ((path.bbox.z - path.bbox.x) * (path.bbox.w - path.bbox.y)) * 8u;\n                Alloc path_alloc = new_alloc(param_20, param_21);\n                uint param_22 = th_ix;\n                Alloc param_23 = path_alloc;\n                write_tile_alloc(param_22, param_23);\n                break;\n            }\n            default:\n            {\n                tile_count = 0u;\n                break;\n            }\n        }\n        sh_tile_count[th_ix] = tile_count;\n        for (uint i_3 = 0u; i_3 < 7u; i_3++)\n        {\n            barrier();\n            if (th_ix >= uint(1 << int(i_3)))\n            {\n                tile_count += sh_tile_count[th_ix - uint(1 << int(i_3))];\n            }\n            barrier();\n            sh_tile_count[th_ix] = tile_count;\n        }\n        barrier();\n        uint total_tile_count = sh_tile_count[127];\n        for (uint ix_1 = th_ix; ix_1 < total_tile_count; ix_1 += 128u)\n        {\n            uint el_ix = 0u;\n            for (uint i_4 = 0u; i_4 < 7u; i_4++)\n            {\n                uint probe_1 = el_ix + uint(64 >> int(i_4));\n                if (ix_1 >= sh_tile_count[probe_1 - 1u])\n                {\n                    el_ix = probe_1;\n                }\n            }\n            AnnotatedRef ref_1 = AnnotatedRef(_1066.conf.anno_alloc.offset + (sh_elements[el_ix] * 32u));\n            param_24.offset = _1066.conf.anno_alloc.offset;\n            AnnotatedRef param_25 = ref_1;\n            uint tag_1 = Annotated_tag(param_24, param_25).tag;\n            if (el_ix > 0u)\n            {\n                _1667 = sh_tile_count[el_ix - 1u];\n            }\n            else\n            {\n                _1667 = 0u;\n            }\n            uint seq_ix = ix_1 - _1667;\n            uint width = sh_tile_width[el_ix];\n            uint x = sh_tile_x0[el_ix] + (seq_ix % width);\n            uint y = sh_tile_y0[el_ix] + (seq_ix / width);\n            if ((tag_1 == 3u) || (tag_1 == 4u))\n            {\n                include_tile = true;\n            }\n            else\n            {\n                uint param_26 = el_ix;\n                Alloc param_27 = read_tile_alloc(param_26);\n                TileRef param_28 = TileRef(sh_tile_base[el_ix] + (((sh_tile_stride[el_ix] * y) + x) * 8u));\n                Tile tile = Tile_read(param_27, param_28);\n                bool _1728 = tile.tile.offset != 0u;\n                bool _1735;\n                if (!_1728)\n                {\n                    _1735 = tile.backdrop != 0;\n                }\n                else\n                {\n                    _1735 = _1728;\n                }\n                include_tile = _1735;\n            }\n            if (include_tile)\n            {\n                uint el_slice = el_ix / 32u;\n                uint el_mask = uint(1 << int(el_ix & 31u));\n                uint _1755 = atomicOr(sh_bitmaps[el_slice][(y * 16u) + x], el_mask);\n            }\n        }\n        barrier();\n        uint slice_ix = 0u;\n        uint bitmap = sh_bitmaps[0][th_ix];\n        while (true)\n        {\n            if (bitmap == 0u)\n            {\n                slice_ix++;\n                if (slice_ix == 4u)\n                {\n                    break;\n                }\n                bitmap = sh_bitmaps[slice_ix][th_ix];\n                if (bitmap == 0u)\n                {\n                    continue;\n                }\n            }\n            uint element_ref_ix = (slice_ix * 32u) + uint(findLSB(bitmap));\n            uint element_ix_1 = sh_elements[element_ref_ix];\n            bitmap &= (bitmap - 1u);\n            ref = AnnotatedRef(_1066.conf.anno_alloc.offset + (element_ix_1 * 32u));\n            param_29.offset = _1066.conf.anno_alloc.offset;\n            AnnotatedRef param_30 = ref;\n            AnnotatedTag tag_2 = Annotated_tag(param_29, param_30);\n            if (clip_zero_depth == 0u)\n            {\n                switch (tag_2.tag)\n                {\n                    case 1u:\n                    {\n                        uint param_31 = element_ref_ix;\n                        Alloc param_32 = read_tile_alloc(param_31);\n                        TileRef param_33 = TileRef(sh_tile_base[element_ref_ix] + (((sh_tile_stride[element_ref_ix] * tile_y) + tile_x) * 8u));\n                        tile_1 = Tile_read(param_32, param_33);\n                        param_34.offset = _1066.conf.anno_alloc.offset;\n                        AnnotatedRef param_35 = ref;\n                        AnnoColor fill = Annotated_Color_read(param_34, param_35);\n                        Alloc param_36 = cmd_alloc;\n                        CmdRef param_37 = cmd_ref;\n                        uint param_38 = cmd_limit;\n                        bool _1865 = alloc_cmd(param_36, param_37, param_38);\n                        cmd_alloc = param_36;\n                        cmd_ref = param_37;\n                        cmd_limit = param_38;\n                        if (!_1865)\n                        {\n                            break;\n                        }\n                        Alloc param_39 = cmd_alloc;\n                        CmdRef param_40 = cmd_ref;\n                        uint param_41 = tag_2.flags;\n                        Tile param_42 = tile_1;\n                        float param_43 = fill.linewidth;\n                        write_fill(param_39, param_40, param_41, param_42, param_43);\n                        cmd_ref = param_40;\n                        Alloc param_44 = cmd_alloc;\n                        CmdRef param_45 = cmd_ref;\n                        CmdColor param_46 = CmdColor(fill.rgba_color);\n                        Cmd_Color_write(param_44, param_45, param_46);\n                        cmd_ref.offset += 8u;\n                        break;\n                    }\n                    case 2u:\n                    {\n                        uint param_47 = element_ref_ix;\n                        Alloc param_48 = read_tile_alloc(param_47);\n                        TileRef param_49 = TileRef(sh_tile_base[element_ref_ix] + (((sh_tile_stride[element_ref_ix] * tile_y) + tile_x) * 8u));\n                        tile_1 = Tile_read(param_48, param_49);\n                        param_50.offset = _1066.conf.anno_alloc.offset;\n                        AnnotatedRef param_51 = ref;\n                        AnnoImage fill_img = Annotated_Image_read(param_50, param_51);\n                        Alloc param_52 = cmd_alloc;\n                        CmdRef param_53 = cmd_ref;\n                        uint param_54 = cmd_limit;\n                        bool _1935 = alloc_cmd(param_52, param_53, param_54);\n                        cmd_alloc = param_52;\n                        cmd_ref = param_53;\n                        cmd_limit = param_54;\n                        if (!_1935)\n                        {\n                            break;\n                        }\n                        Alloc param_55 = cmd_alloc;\n                        CmdRef param_56 = cmd_ref;\n                        uint param_57 = tag_2.flags;\n                        Tile param_58 = tile_1;\n                        float param_59 = fill_img.linewidth;\n                        write_fill(param_55, param_56, param_57, param_58, param_59);\n                        cmd_ref = param_56;\n                        Alloc param_60 = cmd_alloc;\n                        CmdRef param_61 = cmd_ref;\n                        CmdImage param_62 = CmdImage(fill_img.index, fill_img.offset);\n                        Cmd_Image_write(param_60, param_61, param_62);\n                        cmd_ref.offset += 12u;\n                        break;\n                    }\n                    case 3u:\n                    {\n                        uint param_63 = element_ref_ix;\n                        Alloc param_64 = read_tile_alloc(param_63);\n                        TileRef param_65 = TileRef(sh_tile_base[element_ref_ix] + (((sh_tile_stride[element_ref_ix] * tile_y) + tile_x) * 8u));\n                        tile_1 = Tile_read(param_64, param_65);\n                        bool _1994 = tile_1.tile.offset == 0u;\n                        bool _2000;\n                        if (_1994)\n                        {\n                            _2000 = tile_1.backdrop == 0;\n                        }\n                        else\n                        {\n                            _2000 = _1994;\n                        }\n                        if (_2000)\n                        {\n                            clip_zero_depth = clip_depth + 1u;\n                        }\n                        else\n                        {\n                            if ((tile_1.tile.offset == 0u) && (clip_depth < 32u))\n                            {\n                                clip_one_mask |= uint(1 << int(clip_depth));\n                            }\n                            else\n                            {\n                                param_66.offset = _1066.conf.anno_alloc.offset;\n                                AnnotatedRef param_67 = ref;\n                                AnnoBeginClip begin_clip = Annotated_BeginClip_read(param_66, param_67);\n                                Alloc param_68 = cmd_alloc;\n                                CmdRef param_69 = cmd_ref;\n                                uint param_70 = cmd_limit;\n                                bool _2035 = alloc_cmd(param_68, param_69, param_70);\n                                cmd_alloc = param_68;\n                                cmd_ref = param_69;\n                                cmd_limit = param_70;\n                                if (!_2035)\n                                {\n                                    break;\n                                }\n                                Alloc param_71 = cmd_alloc;\n                                CmdRef param_72 = cmd_ref;\n                                uint param_73 = tag_2.flags;\n                                Tile param_74 = tile_1;\n                                float param_75 = begin_clip.linewidth;\n                                write_fill(param_71, param_72, param_73, param_74, param_75);\n                                cmd_ref = param_72;\n                                Alloc param_76 = cmd_alloc;\n                                CmdRef param_77 = cmd_ref;\n                                Cmd_BeginClip_write(param_76, param_77);\n                                cmd_ref.offset += 4u;\n                                if (clip_depth < 32u)\n                                {\n                                    clip_one_mask &= uint(~(1 << int(clip_depth)));\n                                }\n                                begin_slot++;\n                                num_begin_slots = max(num_begin_slots, begin_slot);\n                            }\n                        }\n                        clip_depth++;\n                        break;\n                    }\n                    case 4u:\n                    {\n                        clip_depth--;\n                        bool _2087 = clip_depth >= 32u;\n                        bool _2097;\n                        if (!_2087)\n                        {\n                            _2097 = (clip_one_mask & uint(1 << int(clip_depth))) == 0u;\n                        }\n                        else\n                        {\n                            _2097 = _2087;\n                        }\n                        if (_2097)\n                        {\n                            Alloc param_78 = cmd_alloc;\n                            CmdRef param_79 = cmd_ref;\n                            uint param_80 = cmd_limit;\n                            bool _2106 = alloc_cmd(param_78, param_79, param_80);\n                            cmd_alloc = param_78;\n                            cmd_ref = param_79;\n                            cmd_limit = param_80;\n                            if (!_2106)\n                            {\n                                break;\n                            }\n                            Alloc param_81 = cmd_alloc;\n                            CmdRef param_82 = cmd_ref;\n                            Cmd_Solid_write(param_81, param_82);\n                            cmd_ref.offset += 4u;\n                            begin_slot--;\n                            Alloc param_83 = cmd_alloc;\n                            CmdRef param_84 = cmd_ref;\n                            Cmd_EndClip_write(param_83, param_84);\n                            cmd_ref.offset += 4u;\n                        }\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                switch (tag_2.tag)\n                {\n                    case 3u:\n                    {\n                        clip_depth++;\n                        break;\n                    }\n                    case 4u:\n                    {\n                        if (clip_depth == clip_zero_depth)\n                        {\n                            clip_zero_depth = 0u;\n                        }\n                        clip_depth--;\n                        break;\n                    }\n                }\n            }\n        }\n        barrier();\n        rd_ix += 128u;\n        if ((rd_ix >= ready_ix) && (partition_ix >= n_partitions))\n        {\n            break;\n        }\n    }\n    bool _2171 = (bin_tile_x + tile_x) < _1066.conf.width_in_tiles;\n    bool _2180;\n    if (_2171)\n    {\n        _2180 = (bin_tile_y + tile_y) < _1066.conf.height_in_tiles;\n    }\n    else\n    {\n        _2180 = _2171;\n    }\n    if (_2180)\n    {\n        Alloc param_85 = cmd_alloc;\n        CmdRef param_86 = cmd_ref;\n        Cmd_End_write(param_85, param_86);\n        if (num_begin_slots > 0u)\n        {\n            uint scratch_size = (((num_begin_slots * 32u) * 32u) * 2u) * 4u;\n            uint param_87 = scratch_size;\n            MallocResult _2201 = malloc(param_87);\n            MallocResult scratch = _2201;\n            Alloc param_88 = scratch_alloc;\n            uint param_89 = scratch_alloc.offset;\n            Alloc param_90 = scratch.alloc;\n            alloc_write(param_88, param_89, param_90);\n        }\n    }\n}\n\n",
	}
	shader_copy_frag = driver.ShaderSources{
		Name:      "copy.frag",
		Textures:  []driver.TextureBinding{{Name: "tex", Binding: 0}},
		GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\n\nlayout(location = 0) out highp vec4 fragColor;\n\nhighp vec3 sRGBtoRGB(highp vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.040449999272823333740234375));\n    highp vec3 below = rgb / vec3(12.9200000762939453125);\n    highp vec3 above = pow((rgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));\n    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);\n}\n\nvoid main()\n{\n    highp vec4 texel = texelFetch(tex, ivec2(gl_FragCoord.xy), 0);\n    highp vec3 param = texel.xyz;\n    highp vec3 rgb = sRGBtoRGB(param);\n    fragColor = vec4(rgb, texel.w);\n}\n\n",
		GLSL130:   "#version 130\n\nuniform sampler2D tex;\n\nout vec4 fragColor;\n\nvec3 sRGBtoRGB(vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.040449999272823333740234375));\n    vec3 below = rgb / vec3(12.9200000762939453125);\n    vec3 above = pow((rgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));\n    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);\n}\n\nvoid main()\n{\n    vec4 texel = texelFetch(tex, ivec2(gl_FragCoord.xy), 0);\n    vec3 param = texel.xyz;\n    vec3 rgb = sRGBtoRGB(param);\n    fragColor = vec4(rgb, texel.w);\n}\n\n",
		GLSL150:   "#version 150\n\nuniform sampler2D tex;\n\nout vec4 fragColor;\n\nvec3 sRGBtoRGB(vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.040449999272823333740234375));\n    vec3 below = rgb / vec3(12.9200000762939453125);\n    vec3 above = pow((rgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));\n    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);\n}\n\nvoid main()\n{\n    vec4 texel = texelFetch(tex, ivec2(gl_FragCoord.xy), 0);\n    vec3 param = texel.xyz;\n    vec3 rgb = sRGBtoRGB(param);\n    fragColor = vec4(rgb, texel.w);\n}\n\n",
		HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0xe6, 0x89, 0x5f, 0x74, 0x8b, 0xfc, 0xea, 0x38, 0xd9, 0x27, 0xad, 0x35, 0x2e, 0xc3, 0x88, 0x6b, 0x1, 0x0, 0x0, 0x0, 0x48, 0x3, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0xa4, 0x0, 0x0, 0x0, 0xd8, 0x0, 0x0, 0x0, 0xc, 0x1, 0x0, 0x0, 0xcc, 0x2, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x68, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x74, 0x65, 0x78, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x3, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab, 0x53, 0x48, 0x44, 0x52, 0xb8, 0x1, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x6e, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x64, 0x20, 0x0, 0x4, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x3, 0x0, 0x0, 0x0, 0x1b, 0x0, 0x0, 0x5, 0x32, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xc2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2d, 0x0, 0x0, 0x7, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0xae, 0x47, 0x61, 0x3d, 0xae, 0x47, 0x61, 0x3d, 0xae, 0x47, 0x61, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x6f, 0xa7, 0x72, 0x3f, 0x6f, 0xa7, 0x72, 0x3f, 0x6f, 0xa7, 0x72, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2f, 0x0, 0x0, 0x5, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x9a, 0x99, 0x19, 0x40, 0x9a, 0x99, 0x19, 0x40, 0x9a, 0x99, 0x19, 0x40, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x5, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1d, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0xe6, 0xae, 0x25, 0x3d, 0xe6, 0xae, 0x25, 0x3d, 0xe6, 0xae, 0x25, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x91, 0x83, 0x9e, 0x3d, 0x91, 0x83, 0x9e, 0x3d, 0x91, 0x83, 0x9e, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x82, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x37, 0x0, 0x0, 0x9, 0x72, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
	}
	shader_copy_vert = driver.ShaderSources{
		Name:      "copy.vert",
		GLSL100ES: "\nvoid main()\n{\n    switch (gl_VertexID)\n    {\n        case 0:\n        {\n            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 1:\n        {\n            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 2:\n        {\n            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n        case 3:\n        {\n            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n    }\n}\n\n",
		GLSL300ES: "#version 300 es\n\nvoid main()\n{\n    switch (gl_VertexID)\n    {\n        case 0:\n        {\n            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 1:\n        {\n            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 2:\n        {\n            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n        case 3:\n        {\n            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n    }\n}\n\n",
		GLSL130:   "#version 130\n\nvoid main()\n{\n    switch (gl_VertexID)\n    {\n        case 0:\n        {\n            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 1:\n        {\n            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 2:\n        {\n            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n        case 3:\n        {\n            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n    }\n}\n\n",
		GLSL150:   "#version 150\n\nvoid main()\n{\n    switch (gl_VertexID)\n    {\n        case 0:\n        {\n            gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 1:\n        {\n            gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n            break;\n        }\n        case 2:\n        {\n            gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n        case 3:\n        {\n            gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\n            break;\n        }\n    }\n}\n\n",
		HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0x99, 0xb4, 0x5b, 0xef, 0x5d, 0x49, 0x58, 0xa2, 0x51, 0x68, 0x9f, 0xb6, 0x21, 0x1c, 0x52, 0xe7, 0x1, 0x0, 0x0, 0x0, 0xc0, 0x2, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0xb4, 0x0, 0x0, 0x0, 0xe8, 0x0, 0x0, 0x0, 0x44, 0x2, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x44, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0x53, 0x48, 0x44, 0x52, 0x54, 0x1, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x55, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x4, 0x12, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x4c, 0x0, 0x0, 0x3, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x3, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x6, 0x0, 0x0, 0x3, 0x1, 0x40, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x6, 0x0, 0x0, 0x3, 0x1, 0x40, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x6, 0x0, 0x0, 0x3, 0x1, 0x40, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0xa, 0x0, 0x0, 0x1, 0x36, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x17, 0x0, 0x0, 0x1, 0x36, 0x0, 0x0, 0x5, 0xb2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x42, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x14, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
	}
	shader_cover_frag = [...]driver.ShaderSources{
		{
			Name: "cover.frag",
			Uniforms: driver.UniformsReflection{
				Blocks:    []driver.UniformBlock{{Name: "Color", Binding: 0}},
				Locations: []driver.UniformLocation{{Name: "_12._color", Type: 0x0, Size: 4, Offset: 0}},
				Size:      16,
			},
			Textures:  []driver.TextureBinding{{Name: "cover", Binding: 1}},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nuniform mediump sampler2D cover;\n\nvarying highp vec2 vCoverUV;\nvarying vec2 vUV;\n\nvoid main()\n{\n    gl_FragData[0] = _12._color;\n    float cover_1 = min(abs(texture2D(cover, vCoverUV).x), 1.0);\n    gl_FragData[0] *= cover_1;\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nlayout(std140) uniform Color\n{\n    vec4 _color;\n} _12;\n\nuniform mediump sampler2D cover;\n\nlayout(location = 0) out vec4 fragColor;\nin highp vec2 vCoverUV;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL130:   "#version 130\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vCoverUV;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL150:   "#version 150\n\nstruct Color\n{\n    vec4 _color;\n};\n\nuniform Color _12;\n\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vCoverUV;\nin vec2 vUV;\n\nvoid main()\n{\n    fragColor = _12._color;\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0xbe, 0xef, 0xbf, 0x69, 0x30, 0x75, 0x6b, 0x16, 0xde, 0xd0, 0xe2, 0x98, 0x38, 0x45, 0xf8, 0x59, 0x1, 0x0, 0x0, 0x0, 0xa0, 0x3, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x90, 0x1, 0x0, 0x0, 0xc, 0x2, 0x0, 0x0, 0x20, 0x3, 0x0, 0x0, 0x6c, 0x3, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x8c, 0x0, 0x0, 0x0, 0x8c, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x58, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x28, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x34, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x34, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x0, 0x8, 0xe4, 0xa0, 0x23, 0x0, 0x0, 0x2, 0x0, 0x0, 0x11, 0x80, 0x0, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0xbc, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x2f, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x38, 0x0, 0x0, 0x8, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xc, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x98, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x7c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8b, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x91, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x0, 0xab, 0x91, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xb0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xd4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x0, 0xab, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x44, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
		{
			Name: "cover.frag",
			Uniforms: driver.UniformsReflection{
				Blocks:    []driver.UniformBlock{{Name: "Gradient", Binding: 0}},
				Locations: []driver.UniformLocation{{Name: "_12._color1", Type: 0x0, Size: 4, Offset: 0}, {Name: "_12._color2", Type: 0x0, Size: 4, Offset: 16}},
				Size:      32,
			},
			Textures:  []driver.TextureBinding{{Name: "cover", Binding: 1}},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nuniform mediump sampler2D cover;\n\nvarying vec2 vUV;\nvarying highp vec2 vCoverUV;\n\nvoid main()\n{\n    gl_FragData[0] = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n    float cover_1 = min(abs(texture2D(cover, vCoverUV).x), 1.0);\n    gl_FragData[0] *= cover_1;\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nlayout(std140) uniform Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n} _12;\n\nuniform mediump sampler2D cover;\n\nlayout(location = 0) out vec4 fragColor;\nin vec2 vUV;\nin highp vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL130:   "#version 130\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vUV;\nin vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL150:   "#version 150\n\nstruct Gradient\n{\n    vec4 _color1;\n    vec4 _color2;\n};\n\nuniform Gradient _12;\n\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vUV;\nin vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = mix(_12._color1, _12._color2, vec4(clamp(vUV.x, 0.0, 1.0)));\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0xd2, 0x27, 0xbe, 0xa0, 0xfc, 0x1b, 0xe8, 0x79, 0xd, 0x99, 0xe5, 0xb7, 0xfe, 0x6f, 0x25, 0x6f, 0x1, 0x0, 0x0, 0x0, 0x70, 0x4, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x8, 0x1, 0x0, 0x0, 0x38, 0x2, 0x0, 0x0, 0xb4, 0x2, 0x0, 0x0, 0xf0, 0x3, 0x0, 0x0, 0x3c, 0x4, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0xc8, 0x0, 0x0, 0x0, 0xc8, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x94, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x28, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x34, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x34, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x0, 0x8, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x12, 0x80, 0x0, 0x0, 0xff, 0xb0, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0xf, 0x80, 0x1, 0x0, 0xe4, 0x81, 0x1, 0x0, 0xe4, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0xf, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x23, 0x0, 0x0, 0x2, 0x0, 0x0, 0x11, 0x80, 0x0, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x28, 0x1, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x4a, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x42, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x36, 0x20, 0x0, 0x5, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xf2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xa, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x38, 0x0, 0x0, 0x7, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x34, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0xb, 0x1, 0x0, 0x0, 0x7c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8b, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x91, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0, 0x47, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6e, 0x74, 0x0, 0xab, 0xab, 0x91, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xb4, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x31, 0x0, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x32, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x32, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x44, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x4, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
		{
			Name:      "cover.frag",
			Textures:  []driver.TextureBinding{{Name: "tex", Binding: 0}, {Name: "cover", Binding: 1}},
			GLSL100ES: "precision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\nuniform mediump sampler2D cover;\n\nvarying vec2 vUV;\nvarying highp vec2 vCoverUV;\n\nvoid main()\n{\n    gl_FragData[0] = texture2D(tex, vUV);\n    float cover_1 = min(abs(texture2D(cover, vCoverUV).x), 1.0);\n    gl_FragData[0] *= cover_1;\n}\n\n",
			GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\nuniform mediump sampler2D cover;\n\nlayout(location = 0) out vec4 fragColor;\nin vec2 vUV;\nin highp vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL130:   "#version 130\n\nuniform sampler2D tex;\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vUV;\nin vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			GLSL150:   "#version 150\n\nuniform sampler2D tex;\nuniform sampler2D cover;\n\nout vec4 fragColor;\nin vec2 vUV;\nin vec2 vCoverUV;\n\nvoid main()\n{\n    fragColor = texture(tex, vUV);\n    float cover_1 = min(abs(texture(cover, vCoverUV).x), 1.0);\n    fragColor *= cover_1;\n}\n\n",
			HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0x99, 0x16, 0x6c, 0x60, 0xf6, 0x3a, 0x6b, 0xa2, 0x59, 0x24, 0xa1, 0x2c, 0xfd, 0xcd, 0x4a, 0x45, 0x1, 0x0, 0x0, 0x0, 0xd8, 0x3, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xec, 0x0, 0x0, 0x0, 0xe8, 0x1, 0x0, 0x0, 0x64, 0x2, 0x0, 0x0, 0x58, 0x3, 0x0, 0x0, 0xa4, 0x3, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0xac, 0x0, 0x0, 0x0, 0xac, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x2, 0x0, 0x24, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x2, 0xff, 0xff, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x1, 0x8, 0xf, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0x1b, 0xb0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x0, 0x8, 0xe4, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x1, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x1, 0x8, 0xe4, 0xa0, 0x23, 0x0, 0x0, 0x2, 0x1, 0x0, 0x11, 0x80, 0x1, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0xf4, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x3d, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0xc2, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xe6, 0x1a, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xec, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0xc2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa9, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xb8, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0xbc, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x5f, 0x74, 0x65, 0x78, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x5f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x74, 0x65, 0x78, 0x0, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x44, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0xc, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
		},
	}
	shader_cover_vert = driver.ShaderSources{
		Name:   "cover.vert",
		Inputs: []driver.InputLocation{{Name: "pos", Location: 0, Semantic: "POSITION", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "NORMAL", SemanticIndex: 0, Type: 0x0, Size: 2}},
		Uniforms: driver.UniformsReflection{
			Blocks:    []driver.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []driver.UniformLocation{{Name: "_53.transform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_53.uvCoverTransform", Type: 0x0, Size: 4, Offset: 16}, {Name: "_53.uvTransformR1", Type: 0x0, Size: 4, Offset: 32}, {Name: "_53.uvTransformR2", Type: 0x0, Size: 4, Offset: 48}, {Name: "_53.z", Type: 0x0, Size: 1, Offset: 64}},
			Size:      68,
		},
		GLSL100ES: "\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvCoverTransform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _53;\n\nattribute vec2 pos;\nvarying vec2 vUV;\nattribute vec2 uv;\nvarying vec2 vCoverUV;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec4 param = vec4((pos * _53.transform.xy) + _53.transform.zw, _53.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_53.uvTransformR1.xyz, _53.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_4 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_3, param_4);\n    vCoverUV = ((uv3 * vec3(_53.uvCoverTransform.xy, 1.0)) + vec3(_53.uvCoverTransform.zw, 0.0)).xy;\n}\n\n",
		GLSL300ES: "#version 300 es\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nlayout(std140) uniform Block\n{\n    vec4 transform;\n    vec4 uvCoverTransform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n} _53;\n\nlayout(location = 0) in vec2 pos;\nout vec2 vUV;\nlayout(location = 1) in vec2 uv;\nout vec2 vCoverUV;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec4 param = vec4((pos * _53.transform.xy) + _53.transform.zw, _53.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_53.uvTransformR1.xyz, _53.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_4 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_3, param_4);\n    vCoverUV = ((uv3 * vec3(_53.uvCoverTransform.xy, 1.0)) + vec3(_53.uvCoverTransform.zw, 0.0)).xy;\n}\n\n",
		GLSL130:   "#version 130\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvCoverTransform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _53;\n\nin vec2 pos;\nout vec2 vUV;\nin vec2 uv;\nout vec2 vCoverUV;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec4 param = vec4((pos * _53.transform.xy) + _53.transform.zw, _53.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_53.uvTransformR1.xyz, _53.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_4 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_3, param_4);\n    vCoverUV = ((uv3 * vec3(_53.uvCoverTransform.xy, 1.0)) + vec3(_53.uvCoverTransform.zw, 0.0)).xy;\n}\n\n",
		GLSL150:   "#version 150\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 transform;\n    vec4 uvCoverTransform;\n    vec4 uvTransformR1;\n    vec4 uvTransformR2;\n    float z;\n};\n\nuniform Block _53;\n\nin vec2 pos;\nout vec2 vUV;\nin vec2 uv;\nout vec2 vCoverUV;\n\nvec4 toClipSpace(vec4 pos_1)\n{\n    return pos_1;\n}\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    vec4 param = vec4((pos * _53.transform.xy) + _53.transform.zw, _53.z, 1.0);\n    gl_Position = toClipSpace(param);\n    m3x2 param_1 = m3x2(_53.uvTransformR1.xyz, _53.uvTransformR2.xyz);\n    vec3 param_2 = vec3(uv, 1.0);\n    vUV = transform3x2(param_1, param_2).xy;\n    m3x2 param_3 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_4 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_3, param_4);\n    vCoverUV = ((uv3 * vec3(_53.uvCoverTransform.xy, 1.0)) + vec3(_53.uvCoverTransform.zw, 0.0)).xy;\n}\n\n",
		HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0xb3, 0x71, 0x8c, 0x9f, 0x3e, 0x4f, 0x8b, 0x50, 0xb7, 0xa2, 0x4b, 0xfb, 0xad, 0x7d, 0xc8, 0x71, 0x1, 0x0, 0x0, 0x0, 0xcc, 0x5, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x78, 0x1, 0x0, 0x0, 0x1c, 0x3, 0x0, 0x0, 0x98, 0x3, 0x0, 0x0, 0xc, 0x5, 0x0, 0x0, 0x5c, 0x5, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x38, 0x1, 0x0, 0x0, 0x38, 0x1, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x4, 0x1, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x1, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x51, 0x0, 0x0, 0x5, 0x6, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x0, 0x3f, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x1, 0x80, 0x1, 0x0, 0xf, 0x90, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x7, 0x80, 0x1, 0x0, 0xc4, 0x90, 0x6, 0x0, 0xd0, 0xa0, 0x6, 0x0, 0xc5, 0xa0, 0x8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x8, 0xe0, 0x3, 0x0, 0xe4, 0xa0, 0x0, 0x0, 0xe4, 0x80, 0x8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x4, 0xe0, 0x4, 0x0, 0xe4, 0xa0, 0x0, 0x0, 0xe4, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x1, 0x0, 0xe1, 0x90, 0x6, 0x0, 0xe4, 0xa0, 0x6, 0x0, 0xe1, 0xa0, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x6, 0x0, 0xe2, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x90, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0xe0, 0x0, 0x0, 0xe4, 0x80, 0x2, 0x0, 0xe4, 0xa0, 0x2, 0x0, 0xee, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x90, 0x1, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0xee, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0xc0, 0x0, 0x0, 0xe4, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xb, 0x80, 0x6, 0x0, 0xe4, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0xc, 0xc0, 0x5, 0x0, 0x0, 0xa0, 0x0, 0x0, 0x74, 0x80, 0x0, 0x0, 0x34, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x9c, 0x1, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x67, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xc2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x32, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x42, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0xf, 0x0, 0x0, 0xa, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x96, 0x5, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x8, 0x42, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x82, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x8, 0x82, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x82, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xa, 0x42, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x36, 0x0, 0x0, 0x5, 0x82, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0xb, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x6c, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0x44, 0x1, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x0, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf4, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0x1, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1b, 0x1, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xe4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2d, 0x1, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x34, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x37, 0x30, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0xab, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x37, 0x30, 0x5f, 0x75, 0x76, 0x43, 0x6f, 0x76, 0x65, 0x72, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0x5f, 0x37, 0x30, 0x5f, 0x75, 0x76, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x52, 0x31, 0x0, 0x5f, 0x37, 0x30, 0x5f, 0x75, 0x76, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x52, 0x32, 0x0, 0x5f, 0x37, 0x30, 0x5f, 0x7a, 0x0, 0xab, 0x0, 0x0, 0x3, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x48, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x68, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x3, 0x0, 0x0, 0x59, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0xab, 0xab, 0xab},
	}
	shader_elements_comp = driver.ShaderSources{
		Name:      "elements.comp",
		GLSL310ES: "#version 310 es\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;\n\nstruct Alloc\n{\n    uint offset;\n};\n\nstruct ElementRef\n{\n    uint offset;\n};\n\nstruct LineSegRef\n{\n    uint offset;\n};\n\nstruct LineSeg\n{\n    vec2 p0;\n    vec2 p1;\n};\n\nstruct QuadSegRef\n{\n    uint offset;\n};\n\nstruct QuadSeg\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n};\n\nstruct CubicSegRef\n{\n    uint offset;\n};\n\nstruct CubicSeg\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n    vec2 p3;\n};\n\nstruct FillColorRef\n{\n    uint offset;\n};\n\nstruct FillColor\n{\n    uint rgba_color;\n};\n\nstruct FillImageRef\n{\n    uint offset;\n};\n\nstruct FillImage\n{\n    uint index;\n    ivec2 offset;\n};\n\nstruct SetLineWidthRef\n{\n    uint offset;\n};\n\nstruct SetLineWidth\n{\n    float width;\n};\n\nstruct TransformRef\n{\n    uint offset;\n};\n\nstruct Transform\n{\n    vec4 mat;\n    vec2 translate;\n};\n\nstruct ClipRef\n{\n    uint offset;\n};\n\nstruct Clip\n{\n    vec4 bbox;\n};\n\nstruct SetFillModeRef\n{\n    uint offset;\n};\n\nstruct SetFillMode\n{\n    uint fill_mode;\n};\n\nstruct ElementTag\n{\n    uint tag;\n    uint flags;\n};\n\nstruct StateRef\n{\n    uint offset;\n};\n\nstruct State\n{\n    vec4 mat;\n    vec2 translate;\n    vec4 bbox;\n    float linewidth;\n    uint flags;\n    uint path_count;\n    uint pathseg_count;\n    uint trans_count;\n};\n\nstruct AnnoImageRef\n{\n    uint offset;\n};\n\nstruct AnnoImage\n{\n    vec4 bbox;\n    float linewidth;\n    uint index;\n    ivec2 offset;\n};\n\nstruct AnnoColorRef\n{\n    uint offset;\n};\n\nstruct AnnoColor\n{\n    vec4 bbox;\n    float linewidth;\n    uint rgba_color;\n};\n\nstruct AnnoBeginClipRef\n{\n    uint offset;\n};\n\nstruct AnnoBeginClip\n{\n    vec4 bbox;\n    float linewidth;\n};\n\nstruct AnnoEndClipRef\n{\n    uint offset;\n};\n\nstruct AnnoEndClip\n{\n    vec4 bbox;\n};\n\nstruct AnnotatedRef\n{\n    uint offset;\n};\n\nstruct PathCubicRef\n{\n    uint offset;\n};\n\nstruct PathCubic\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n    vec2 p3;\n    uint path_ix;\n    uint trans_ix;\n    vec2 stroke;\n};\n\nstruct PathSegRef\n{\n    uint offset;\n};\n\nstruct TransformSegRef\n{\n    uint offset;\n};\n\nstruct TransformSeg\n{\n    vec4 mat;\n    vec2 translate;\n};\n\nstruct Config\n{\n    uint n_elements;\n    uint n_pathseg;\n    uint width_in_tiles;\n    uint height_in_tiles;\n    Alloc tile_alloc;\n    Alloc bin_alloc;\n    Alloc ptcl_alloc;\n    Alloc pathseg_alloc;\n    Alloc anno_alloc;\n    Alloc trans_alloc;\n};\n\nlayout(binding = 0, std430) buffer Memory\n{\n    uint mem_offset;\n    uint mem_error;\n    uint memory[];\n} _294;\n\nlayout(binding = 2, std430) readonly buffer SceneBuf\n{\n    uint scene[];\n} _323;\n\nlayout(binding = 3, std430) coherent buffer StateBuf\n{\n    uint part_counter;\n    uint state[];\n} _779;\n\nlayout(binding = 1, std430) readonly buffer ConfigBuf\n{\n    Config conf;\n} _2435;\n\nshared uint sh_part_ix;\nshared State sh_state[32];\nshared State sh_prefix;\n\nElementTag Element_tag(ElementRef ref)\n{\n    uint tag_and_flags = _323.scene[ref.offset >> uint(2)];\n    return ElementTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));\n}\n\nLineSeg LineSeg_read(LineSegRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    uint raw0 = _323.scene[ix + 0u];\n    uint raw1 = _323.scene[ix + 1u];\n    uint raw2 = _323.scene[ix + 2u];\n    uint raw3 = _323.scene[ix + 3u];\n    LineSeg s;\n    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\n    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    return s;\n}\n\nLineSeg Element_Line_read(ElementRef ref)\n{\n    LineSegRef param = LineSegRef(ref.offset + 4u);\n    return LineSeg_read(param);\n}\n\nQuadSeg QuadSeg_read(QuadSegRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    uint raw0 = _323.scene[ix + 0u];\n    uint raw1 = _323.scene[ix + 1u];\n    uint raw2 = _323.scene[ix + 2u];\n    uint raw3 = _323.scene[ix + 3u];\n    uint raw4 = _323.scene[ix + 4u];\n    uint raw5 = _323.scene[ix + 5u];\n    QuadSeg s;\n    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\n    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    s.p2 = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\n    return s;\n}\n\nQuadSeg Element_Quad_read(ElementRef ref)\n{\n    QuadSegRef param = QuadSegRef(ref.offset + 4u);\n    return QuadSeg_read(param);\n}\n\nCubicSeg CubicSeg_read(CubicSegRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    uint raw0 = _323.scene[ix + 0u];\n    uint raw1 = _323.scene[ix + 1u];\n    uint raw2 = _323.scene[ix + 2u];\n    uint raw3 = _323.scene[ix + 3u];\n    uint raw4 = _323.scene[ix + 4u];\n    uint raw5 = _323.scene[ix + 5u];\n    uint raw6 = _323.scene[ix + 6u];\n    uint raw7 = _323.scene[ix + 7u];\n    CubicSeg s;\n    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\n    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    s.p2 = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\n    s.p3 = vec2(uintBitsToFloat(raw6), uintBitsToFloat(raw7));\n    return s;\n}\n\nCubicSeg Element_Cubic_read(ElementRef ref)\n{\n    CubicSegRef param = CubicSegRef(ref.offset + 4u);\n    return CubicSeg_read(param);\n}\n\nSetLineWidth SetLineWidth_read(SetLineWidthRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    uint raw0 = _323.scene[ix + 0u];\n    SetLineWidth s;\n    s.width = uintBitsToFloat(raw0);\n    return s;\n}\n\nSetLineWidth Element_SetLineWidth_read(ElementRef ref)\n{\n    SetLineWidthRef param = SetLineWidthRef(ref.offset + 4u);\n    return SetLineWidth_read(param);\n}\n\nTransform Transform_read(TransformRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    uint raw0 = _323.scene[ix + 0u];\n    uint raw1 = _323.scene[ix + 1u];\n    uint raw2 = _323.scene[ix + 2u];\n    uint raw3 = _323.scene[ix + 3u];\n    uint raw4 = _323.scene[ix + 4u];\n    uint raw5 = _323.scene[ix + 5u];\n    Transform s;\n    s.mat = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    s.translate = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\n    return s;\n}\n\nTransform Element_Transform_read(ElementRef ref)\n{\n    TransformRef param = TransformRef(ref.offset + 4u);\n    return Transform_read(param);\n}\n\nSetFillMode SetFillMode_read(SetFillModeRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    uint raw0 = _323.scene[ix + 0u];\n    SetFillMode s;\n    s.fill_mode = raw0;\n    return s;\n}\n\nSetFillMode Element_SetFillMode_read(ElementRef ref)\n{\n    SetFillModeRef param = SetFillModeRef(ref.offset + 4u);\n    return SetFillMode_read(param);\n}\n\nState map_element(ElementRef ref)\n{\n    ElementRef param = ref;\n    uint tag = Element_tag(param).tag;\n    State c;\n    c.bbox = vec4(0.0);\n    c.mat = vec4(1.0, 0.0, 0.0, 1.0);\n    c.translate = vec2(0.0);\n    c.linewidth = 1.0;\n    c.flags = 0u;\n    c.path_count = 0u;\n    c.pathseg_count = 0u;\n    c.trans_count = 0u;\n    switch (tag)\n    {\n        case 1u:\n        {\n            ElementRef param_1 = ref;\n            LineSeg line = Element_Line_read(param_1);\n            vec2 _1919 = min(line.p0, line.p1);\n            c.bbox = vec4(_1919.x, _1919.y, c.bbox.z, c.bbox.w);\n            vec2 _1927 = max(line.p0, line.p1);\n            c.bbox = vec4(c.bbox.x, c.bbox.y, _1927.x, _1927.y);\n            c.pathseg_count = 1u;\n            break;\n        }\n        case 2u:\n        {\n            ElementRef param_2 = ref;\n            QuadSeg quad = Element_Quad_read(param_2);\n            vec2 _1944 = min(min(quad.p0, quad.p1), quad.p2);\n            c.bbox = vec4(_1944.x, _1944.y, c.bbox.z, c.bbox.w);\n            vec2 _1955 = max(max(quad.p0, quad.p1), quad.p2);\n            c.bbox = vec4(c.bbox.x, c.bbox.y, _1955.x, _1955.y);\n            c.pathseg_count = 1u;\n            break;\n        }\n        case 3u:\n        {\n            ElementRef param_3 = ref;\n            CubicSeg cubic = Element_Cubic_read(param_3);\n            vec2 _1975 = min(min(cubic.p0, cubic.p1), min(cubic.p2, cubic.p3));\n            c.bbox = vec4(_1975.x, _1975.y, c.bbox.z, c.bbox.w);\n            vec2 _1989 = max(max(cubic.p0, cubic.p1), max(cubic.p2, cubic.p3));\n            c.bbox = vec4(c.bbox.x, c.bbox.y, _1989.x, _1989.y);\n            c.pathseg_count = 1u;\n            break;\n        }\n        case 4u:\n        case 9u:\n        case 7u:\n        {\n            c.flags = 4u;\n            c.path_count = 1u;\n            break;\n        }\n        case 8u:\n        {\n            c.path_count = 1u;\n            break;\n        }\n        case 5u:\n        {\n            ElementRef param_4 = ref;\n            SetLineWidth lw = Element_SetLineWidth_read(param_4);\n            c.linewidth = lw.width;\n            c.flags = 1u;\n            break;\n        }\n        case 6u:\n        {\n            ElementRef param_5 = ref;\n            Transform t = Element_Transform_read(param_5);\n            c.mat = t.mat;\n            c.translate = t.translate;\n            c.trans_count = 1u;\n            break;\n        }\n        case 10u:\n        {\n            ElementRef param_6 = ref;\n            SetFillMode fm = Element_SetFillMode_read(param_6);\n            c.flags = 8u | (fm.fill_mode << uint(4));\n            break;\n        }\n    }\n    return c;\n}\n\nElementRef Element_index(ElementRef ref, uint index)\n{\n    return ElementRef(ref.offset + (index * 36u));\n}\n\nState combine_state(State a, State b)\n{\n    State c;\n    c.bbox.x = (min(a.mat.x * b.bbox.x, a.mat.x * b.bbox.z) + min(a.mat.z * b.bbox.y, a.mat.z * b.bbox.w)) + a.translate.x;\n    c.bbox.y = (min(a.mat.y * b.bbox.x, a.mat.y * b.bbox.z) + min(a.mat.w * b.bbox.y, a.mat.w * b.bbox.w)) + a.translate.y;\n    c.bbox.z = (max(a.mat.x * b.bbox.x, a.mat.x * b.bbox.z) + max(a.mat.z * b.bbox.y, a.mat.z * b.bbox.w)) + a.translate.x;\n    c.bbox.w = (max(a.mat.y * b.bbox.x, a.mat.y * b.bbox.z) + max(a.mat.w * b.bbox.y, a.mat.w * b.bbox.w)) + a.translate.y;\n    bool _1657 = (a.flags & 4u) == 0u;\n    bool _1665;\n    if (_1657)\n    {\n        _1665 = b.bbox.z <= b.bbox.x;\n    }\n    else\n    {\n        _1665 = _1657;\n    }\n    bool _1673;\n    if (_1665)\n    {\n        _1673 = b.bbox.w <= b.bbox.y;\n    }\n    else\n    {\n        _1673 = _1665;\n    }\n    if (_1673)\n    {\n        c.bbox = a.bbox;\n    }\n    else\n    {\n        bool _1683 = (a.flags & 4u) == 0u;\n        bool _1690;\n        if (_1683)\n        {\n            _1690 = (b.flags & 2u) == 0u;\n        }\n        else\n        {\n            _1690 = _1683;\n        }\n        bool _1707;\n        if (_1690)\n        {\n            bool _1697 = a.bbox.z > a.bbox.x;\n            bool _1706;\n            if (!_1697)\n            {\n                _1706 = a.bbox.w > a.bbox.y;\n            }\n            else\n            {\n                _1706 = _1697;\n            }\n            _1707 = _1706;\n        }\n        else\n        {\n            _1707 = _1690;\n        }\n        if (_1707)\n        {\n            vec2 _1716 = min(a.bbox.xy, c.bbox.xy);\n            c.bbox = vec4(_1716.x, _1716.y, c.bbox.z, c.bbox.w);\n            vec2 _1726 = max(a.bbox.zw, c.bbox.zw);\n            c.bbox = vec4(c.bbox.x, c.bbox.y, _1726.x, _1726.y);\n        }\n    }\n    c.mat.x = (a.mat.x * b.mat.x) + (a.mat.z * b.mat.y);\n    c.mat.y = (a.mat.y * b.mat.x) + (a.mat.w * b.mat.y);\n    c.mat.z = (a.mat.x * b.mat.z) + (a.mat.z * b.mat.w);\n    c.mat.w = (a.mat.y * b.mat.z) + (a.mat.w * b.mat.w);\n    c.translate.x = ((a.mat.x * b.translate.x) + (a.mat.z * b.translate.y)) + a.translate.x;\n    c.translate.y = ((a.mat.y * b.translate.x) + (a.mat.w * b.translate.y)) + a.translate.y;\n    float _1812;\n    if ((b.flags & 1u) == 0u)\n    {\n        _1812 = a.linewidth;\n    }\n    else\n    {\n        _1812 = b.linewidth;\n    }\n    c.linewidth = _1812;\n    c.flags = (a.flags & 11u) | b.flags;\n    c.flags |= ((a.flags & 4u) >> uint(1));\n    uint _1842;\n    if ((b.flags & 8u) == 0u)\n    {\n        _1842 = a.flags;\n    }\n    else\n    {\n        _1842 = b.flags;\n    }\n    uint fill_mode = _1842;\n    fill_mode &= 16u;\n    c.flags = (c.flags & 4294967279u) | fill_mode;\n    c.path_count = a.path_count + b.path_count;\n    c.pathseg_count = a.pathseg_count + b.pathseg_count;\n    c.trans_count = a.trans_count + b.trans_count;\n    return c;\n}\n\nStateRef state_aggregate_ref(uint partition_ix)\n{\n    return StateRef(4u + (partition_ix * 124u));\n}\n\nvoid State_write(StateRef ref, State s)\n{\n    uint ix = ref.offset >> uint(2);\n    _779.state[ix + 0u] = floatBitsToUint(s.mat.x);\n    _779.state[ix + 1u] = floatBitsToUint(s.mat.y);\n    _779.state[ix + 2u] = floatBitsToUint(s.mat.z);\n    _779.state[ix + 3u] = floatBitsToUint(s.mat.w);\n    _779.state[ix + 4u] = floatBitsToUint(s.translate.x);\n    _779.state[ix + 5u] = floatBitsToUint(s.translate.y);\n    _779.state[ix + 6u] = floatBitsToUint(s.bbox.x);\n    _779.state[ix + 7u] = floatBitsToUint(s.bbox.y);\n    _779.state[ix + 8u] = floatBitsToUint(s.bbox.z);\n    _779.state[ix + 9u] = floatBitsToUint(s.bbox.w);\n    _779.state[ix + 10u] = floatBitsToUint(s.linewidth);\n    _779.state[ix + 11u] = s.flags;\n    _779.state[ix + 12u] = s.path_count;\n    _779.state[ix + 13u] = s.pathseg_count;\n    _779.state[ix + 14u] = s.trans_count;\n}\n\nStateRef state_prefix_ref(uint partition_ix)\n{\n    return StateRef((4u + (partition_ix * 124u)) + 60u);\n}\n\nuint state_flag_index(uint partition_ix)\n{\n    return partition_ix * 31u;\n}\n\nState State_read(StateRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    uint raw0 = _779.state[ix + 0u];\n    uint raw1 = _779.state[ix + 1u];\n    uint raw2 = _779.state[ix + 2u];\n    uint raw3 = _779.state[ix + 3u];\n    uint raw4 = _779.state[ix + 4u];\n    uint raw5 = _779.state[ix + 5u];\n    uint raw6 = _779.state[ix + 6u];\n    uint raw7 = _779.state[ix + 7u];\n    uint raw8 = _779.state[ix + 8u];\n    uint raw9 = _779.state[ix + 9u];\n    uint raw10 = _779.state[ix + 10u];\n    uint raw11 = _779.state[ix + 11u];\n    uint raw12 = _779.state[ix + 12u];\n    uint raw13 = _779.state[ix + 13u];\n    uint raw14 = _779.state[ix + 14u];\n    State s;\n    s.mat = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    s.translate = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\n    s.bbox = vec4(uintBitsToFloat(raw6), uintBitsToFloat(raw7), uintBitsToFloat(raw8), uintBitsToFloat(raw9));\n    s.linewidth = uintBitsToFloat(raw10);\n    s.flags = raw11;\n    s.path_count = raw12;\n    s.pathseg_count = raw13;\n    s.trans_count = raw14;\n    return s;\n}\n\nuint fill_mode_from_flags(uint flags)\n{\n    return flags & 1u;\n}\n\nvec2 get_linewidth(State st)\n{\n    return vec2(length(st.mat.xz), length(st.mat.yw)) * (0.5 * st.linewidth);\n}\n\nbool touch_mem(Alloc alloc, uint offset)\n{\n    return true;\n}\n\nvoid write_mem(Alloc alloc, uint offset, uint val)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return;\n    }\n    _294.memory[offset] = val;\n}\n\nvoid PathCubic_write(Alloc a, PathCubicRef ref, PathCubic s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = floatBitsToUint(s.p0.x);\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = floatBitsToUint(s.p0.y);\n    write_mem(param_3, param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 2u;\n    uint param_8 = floatBitsToUint(s.p1.x);\n    write_mem(param_6, param_7, param_8);\n    Alloc param_9 = a;\n    uint param_10 = ix + 3u;\n    uint param_11 = floatBitsToUint(s.p1.y);\n    write_mem(param_9, param_10, param_11);\n    Alloc param_12 = a;\n    uint param_13 = ix + 4u;\n    uint param_14 = floatBitsToUint(s.p2.x);\n    write_mem(param_12, param_13, param_14);\n    Alloc param_15 = a;\n    uint param_16 = ix + 5u;\n    uint param_17 = floatBitsToUint(s.p2.y);\n    write_mem(param_15, param_16, param_17);\n    Alloc param_18 = a;\n    uint param_19 = ix + 6u;\n    uint param_20 = floatBitsToUint(s.p3.x);\n    write_mem(param_18, param_19, param_20);\n    Alloc param_21 = a;\n    uint param_22 = ix + 7u;\n    uint param_23 = floatBitsToUint(s.p3.y);\n    write_mem(param_21, param_22, param_23);\n    Alloc param_24 = a;\n    uint param_25 = ix + 8u;\n    uint param_26 = s.path_ix;\n    write_mem(param_24, param_25, param_26);\n    Alloc param_27 = a;\n    uint param_28 = ix + 9u;\n    uint param_29 = s.trans_ix;\n    write_mem(param_27, param_28, param_29);\n    Alloc param_30 = a;\n    uint param_31 = ix + 10u;\n    uint param_32 = floatBitsToUint(s.stroke.x);\n    write_mem(param_30, param_31, param_32);\n    Alloc param_33 = a;\n    uint param_34 = ix + 11u;\n    uint param_35 = floatBitsToUint(s.stroke.y);\n    write_mem(param_33, param_34, param_35);\n}\n\nvoid PathSeg_Cubic_write(Alloc a, PathSegRef ref, uint flags, PathCubic s)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = (flags << uint(16)) | 1u;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    PathCubicRef param_4 = PathCubicRef(ref.offset + 4u);\n    PathCubic param_5 = s;\n    PathCubic_write(param_3, param_4, param_5);\n}\n\nFillColor FillColor_read(FillColorRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    uint raw0 = _323.scene[ix + 0u];\n    FillColor s;\n    s.rgba_color = raw0;\n    return s;\n}\n\nFillColor Element_FillColor_read(ElementRef ref)\n{\n    FillColorRef param = FillColorRef(ref.offset + 4u);\n    return FillColor_read(param);\n}\n\nvoid AnnoColor_write(Alloc a, AnnoColorRef ref, AnnoColor s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = floatBitsToUint(s.bbox.x);\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = floatBitsToUint(s.bbox.y);\n    write_mem(param_3, param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 2u;\n    uint param_8 = floatBitsToUint(s.bbox.z);\n    write_mem(param_6, param_7, param_8);\n    Alloc param_9 = a;\n    uint param_10 = ix + 3u;\n    uint param_11 = floatBitsToUint(s.bbox.w);\n    write_mem(param_9, param_10, param_11);\n    Alloc param_12 = a;\n    uint param_13 = ix + 4u;\n    uint param_14 = floatBitsToUint(s.linewidth);\n    write_mem(param_12, param_13, param_14);\n    Alloc param_15 = a;\n    uint param_16 = ix + 5u;\n    uint param_17 = s.rgba_color;\n    write_mem(param_15, param_16, param_17);\n}\n\nvoid Annotated_Color_write(Alloc a, AnnotatedRef ref, uint flags, AnnoColor s)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = (flags << uint(16)) | 1u;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    AnnoColorRef param_4 = AnnoColorRef(ref.offset + 4u);\n    AnnoColor param_5 = s;\n    AnnoColor_write(param_3, param_4, param_5);\n}\n\nFillImage FillImage_read(FillImageRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    uint raw0 = _323.scene[ix + 0u];\n    uint raw1 = _323.scene[ix + 1u];\n    FillImage s;\n    s.index = raw0;\n    s.offset = ivec2(int(raw1 << uint(16)) >> 16, int(raw1) >> 16);\n    return s;\n}\n\nFillImage Element_FillImage_read(ElementRef ref)\n{\n    FillImageRef param = FillImageRef(ref.offset + 4u);\n    return FillImage_read(param);\n}\n\nvoid AnnoImage_write(Alloc a, AnnoImageRef ref, AnnoImage s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = floatBitsToUint(s.bbox.x);\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = floatBitsToUint(s.bbox.y);\n    write_mem(param_3, param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 2u;\n    uint param_8 = floatBitsToUint(s.bbox.z);\n    write_mem(param_6, param_7, param_8);\n    Alloc param_9 = a;\n    uint param_10 = ix + 3u;\n    uint param_11 = floatBitsToUint(s.bbox.w);\n    write_mem(param_9, param_10, param_11);\n    Alloc param_12 = a;\n    uint param_13 = ix + 4u;\n    uint param_14 = floatBitsToUint(s.linewidth);\n    write_mem(param_12, param_13, param_14);\n    Alloc param_15 = a;\n    uint param_16 = ix + 5u;\n    uint param_17 = s.index;\n    write_mem(param_15, param_16, param_17);\n    Alloc param_18 = a;\n    uint param_19 = ix + 6u;\n    uint param_20 = (uint(s.offset.x) & 65535u) | (uint(s.offset.y) << uint(16));\n    write_mem(param_18, param_19, param_20);\n}\n\nvoid Annotated_Image_write(Alloc a, AnnotatedRef ref, uint flags, AnnoImage s)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = (flags << uint(16)) | 2u;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    AnnoImageRef param_4 = AnnoImageRef(ref.offset + 4u);\n    AnnoImage param_5 = s;\n    AnnoImage_write(param_3, param_4, param_5);\n}\n\nClip Clip_read(ClipRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    uint raw0 = _323.scene[ix + 0u];\n    uint raw1 = _323.scene[ix + 1u];\n    uint raw2 = _323.scene[ix + 2u];\n    uint raw3 = _323.scene[ix + 3u];\n    Clip s;\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    return s;\n}\n\nClip Element_BeginClip_read(ElementRef ref)\n{\n    ClipRef param = ClipRef(ref.offset + 4u);\n    return Clip_read(param);\n}\n\nvoid AnnoBeginClip_write(Alloc a, AnnoBeginClipRef ref, AnnoBeginClip s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = floatBitsToUint(s.bbox.x);\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = floatBitsToUint(s.bbox.y);\n    write_mem(param_3, param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 2u;\n    uint param_8 = floatBitsToUint(s.bbox.z);\n    write_mem(param_6, param_7, param_8);\n    Alloc param_9 = a;\n    uint param_10 = ix + 3u;\n    uint param_11 = floatBitsToUint(s.bbox.w);\n    write_mem(param_9, param_10, param_11);\n    Alloc param_12 = a;\n    uint param_13 = ix + 4u;\n    uint param_14 = floatBitsToUint(s.linewidth);\n    write_mem(param_12, param_13, param_14);\n}\n\nvoid Annotated_BeginClip_write(Alloc a, AnnotatedRef ref, uint flags, AnnoBeginClip s)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = (flags << uint(16)) | 3u;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    AnnoBeginClipRef param_4 = AnnoBeginClipRef(ref.offset + 4u);\n    AnnoBeginClip param_5 = s;\n    AnnoBeginClip_write(param_3, param_4, param_5);\n}\n\nClip Element_EndClip_read(ElementRef ref)\n{\n    ClipRef param = ClipRef(ref.offset + 4u);\n    return Clip_read(param);\n}\n\nvoid AnnoEndClip_write(Alloc a, AnnoEndClipRef ref, AnnoEndClip s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = floatBitsToUint(s.bbox.x);\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = floatBitsToUint(s.bbox.y);\n    write_mem(param_3, param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 2u;\n    uint param_8 = floatBitsToUint(s.bbox.z);\n    write_mem(param_6, param_7, param_8);\n    Alloc param_9 = a;\n    uint param_10 = ix + 3u;\n    uint param_11 = floatBitsToUint(s.bbox.w);\n    write_mem(param_9, param_10, param_11);\n}\n\nvoid Annotated_EndClip_write(Alloc a, AnnotatedRef ref, AnnoEndClip s)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint param_2 = 4u;\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    AnnoEndClipRef param_4 = AnnoEndClipRef(ref.offset + 4u);\n    AnnoEndClip param_5 = s;\n    AnnoEndClip_write(param_3, param_4, param_5);\n}\n\nvoid TransformSeg_write(Alloc a, TransformSegRef ref, TransformSeg s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = floatBitsToUint(s.mat.x);\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = floatBitsToUint(s.mat.y);\n    write_mem(param_3, param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 2u;\n    uint param_8 = floatBitsToUint(s.mat.z);\n    write_mem(param_6, param_7, param_8);\n    Alloc param_9 = a;\n    uint param_10 = ix + 3u;\n    uint param_11 = floatBitsToUint(s.mat.w);\n    write_mem(param_9, param_10, param_11);\n    Alloc param_12 = a;\n    uint param_13 = ix + 4u;\n    uint param_14 = floatBitsToUint(s.translate.x);\n    write_mem(param_12, param_13, param_14);\n    Alloc param_15 = a;\n    uint param_16 = ix + 5u;\n    uint param_17 = floatBitsToUint(s.translate.y);\n    write_mem(param_15, param_16, param_17);\n}\n\nvoid main()\n{\n    if (_294.mem_error != 0u)\n    {\n        return;\n    }\n    if (gl_LocalInvocationID.x == 0u)\n    {\n        uint _2069 = atomicAdd(_779.part_counter, 1u);\n        sh_part_ix = _2069;\n    }\n    barrier();\n    uint part_ix = sh_part_ix;\n    uint ix = (part_ix * 128u) + (gl_LocalInvocationID.x * 4u);\n    ElementRef ref = ElementRef(ix * 36u);\n    ElementRef param = ref;\n    State th_state[4];\n    th_state[0] = map_element(param);\n    for (uint i = 1u; i < 4u; i++)\n    {\n        ElementRef param_1 = ref;\n        uint param_2 = i;\n        ElementRef param_3 = Element_index(param_1, param_2);\n        State param_4 = th_state[i - 1u];\n        State param_5 = map_element(param_3);\n        th_state[i] = combine_state(param_4, param_5);\n    }\n    State agg = th_state[3];\n    sh_state[gl_LocalInvocationID.x] = agg;\n    for (uint i_1 = 0u; i_1 < 5u; i_1++)\n    {\n        barrier();\n        if (gl_LocalInvocationID.x >= uint(1 << int(i_1)))\n        {\n            State other = sh_state[gl_LocalInvocationID.x - uint(1 << int(i_1))];\n            State param_6 = other;\n            State param_7 = agg;\n            agg = combine_state(param_6, param_7);\n        }\n        barrier();\n        sh_state[gl_LocalInvocationID.x] = agg;\n    }\n    State exclusive;\n    exclusive.bbox = vec4(0.0);\n    exclusive.mat = vec4(1.0, 0.0, 0.0, 1.0);\n    exclusive.translate = vec2(0.0);\n    exclusive.linewidth = 1.0;\n    exclusive.flags = 0u;\n    exclusive.path_count = 0u;\n    exclusive.pathseg_count = 0u;\n    exclusive.trans_count = 0u;\n    if (gl_LocalInvocationID.x == 31u)\n    {\n        uint param_8 = part_ix;\n        StateRef param_9 = state_aggregate_ref(param_8);\n        State param_10 = agg;\n        State_write(param_9, param_10);\n        uint flag = 1u;\n        memoryBarrierBuffer();\n        if (part_ix == 0u)\n        {\n            uint param_11 = part_ix;\n            StateRef param_12 = state_prefix_ref(param_11);\n            State param_13 = agg;\n            State_write(param_12, param_13);\n            flag = 2u;\n        }\n        uint param_14 = part_ix;\n        _779.state[state_flag_index(param_14)] = flag;\n        if (part_ix != 0u)\n        {\n            uint look_back_ix = part_ix - 1u;\n            uint their_ix = 0u;\n            State their_agg;\n            while (true)\n            {\n                uint param_15 = look_back_ix;\n                flag = _779.state[state_flag_index(param_15)];\n                if (flag == 2u)\n                {\n                    uint param_16 = look_back_ix;\n                    StateRef param_17 = state_prefix_ref(param_16);\n                    State their_prefix = State_read(param_17);\n                    State param_18 = their_prefix;\n                    State param_19 = exclusive;\n                    exclusive = combine_state(param_18, param_19);\n                    break;\n                }\n                else\n                {\n                    if (flag == 1u)\n                    {\n                        uint param_20 = look_back_ix;\n                        StateRef param_21 = state_aggregate_ref(param_20);\n                        their_agg = State_read(param_21);\n                        State param_22 = their_agg;\n                        State param_23 = exclusive;\n                        exclusive = combine_state(param_22, param_23);\n                        look_back_ix--;\n                        their_ix = 0u;\n                        continue;\n                    }\n                }\n                ElementRef ref_1 = ElementRef(((look_back_ix * 128u) + their_ix) * 36u);\n                ElementRef param_24 = ref_1;\n                State s = map_element(param_24);\n                if (their_ix == 0u)\n                {\n                    their_agg = s;\n                }\n                else\n                {\n                    State param_25 = their_agg;\n                    State param_26 = s;\n                    their_agg = combine_state(param_25, param_26);\n                }\n                their_ix++;\n                if (their_ix == 128u)\n                {\n                    State param_27 = their_agg;\n                    State param_28 = exclusive;\n                    exclusive = combine_state(param_27, param_28);\n                    if (look_back_ix == 0u)\n                    {\n                        break;\n                    }\n                    look_back_ix--;\n                    their_ix = 0u;\n                }\n            }\n            State param_29 = exclusive;\n            State param_30 = agg;\n            State inclusive_prefix = combine_state(param_29, param_30);\n            sh_prefix = exclusive;\n            uint param_31 = part_ix;\n            StateRef param_32 = state_prefix_ref(param_31);\n            State param_33 = inclusive_prefix;\n            State_write(param_32, param_33);\n            memoryBarrierBuffer();\n            flag = 2u;\n            uint param_34 = part_ix;\n            _779.state[state_flag_index(param_34)] = flag;\n        }\n    }\n    barrier();\n    if (part_ix != 0u)\n    {\n        exclusive = sh_prefix;\n    }\n    State row = exclusive;\n    if (gl_LocalInvocationID.x > 0u)\n    {\n        State other_1 = sh_state[gl_LocalInvocationID.x - 1u];\n        State param_35 = row;\n        State param_36 = other_1;\n        row = combine_state(param_35, param_36);\n    }\n    PathCubic path_cubic;\n    PathSegRef path_out_ref;\n    Alloc param_45;\n    Alloc param_51;\n    Alloc param_57;\n    AnnoColor anno_fill;\n    AnnotatedRef out_ref;\n    Alloc param_63;\n    AnnoImage anno_img;\n    Alloc param_69;\n    AnnoBeginClip anno_begin_clip;\n    Alloc param_75;\n    Alloc param_80;\n    Alloc param_83;\n    for (uint i_2 = 0u; i_2 < 4u; i_2++)\n    {\n        State param_37 = row;\n        State param_38 = th_state[i_2];\n        State st = combine_state(param_37, param_38);\n        ElementRef param_39 = ref;\n        uint param_40 = i_2;\n        ElementRef this_ref = Element_index(param_39, param_40);\n        ElementRef param_41 = this_ref;\n        ElementTag tag = Element_tag(param_41);\n        uint param_42 = st.flags >> uint(4);\n        uint fill_mode = fill_mode_from_flags(param_42);\n        bool is_stroke = fill_mode == 1u;\n        switch (tag.tag)\n        {\n            case 1u:\n            {\n                ElementRef param_43 = this_ref;\n                LineSeg line = Element_Line_read(param_43);\n                path_cubic.p0 = line.p0;\n                path_cubic.p1 = mix(line.p0, line.p1, vec2(0.3333333432674407958984375));\n                path_cubic.p2 = mix(line.p1, line.p0, vec2(0.3333333432674407958984375));\n                path_cubic.p3 = line.p1;\n                path_cubic.path_ix = st.path_count;\n                path_cubic.trans_ix = st.trans_count;\n                if (is_stroke)\n                {\n                    State param_44 = st;\n                    path_cubic.stroke = get_linewidth(param_44);\n                }\n                else\n                {\n                    path_cubic.stroke = vec2(0.0);\n                }\n                path_out_ref = PathSegRef(_2435.conf.pathseg_alloc.offset + ((st.pathseg_count - 1u) * 52u));\n                param_45.offset = _2435.conf.pathseg_alloc.offset;\n                PathSegRef param_46 = path_out_ref;\n                uint param_47 = fill_mode;\n                PathCubic param_48 = path_cubic;\n                PathSeg_Cubic_write(param_45, param_46, param_47, param_48);\n                break;\n            }\n            case 2u:\n            {\n                ElementRef param_49 = this_ref;\n                QuadSeg quad = Element_Quad_read(param_49);\n                path_cubic.p0 = quad.p0;\n                path_cubic.p1 = mix(quad.p1, quad.p0, vec2(0.3333333432674407958984375));\n                path_cubic.p2 = mix(quad.p1, quad.p2, vec2(0.3333333432674407958984375));\n                path_cubic.p3 = quad.p2;\n                path_cubic.path_ix = st.path_count;\n                path_cubic.trans_ix = st.trans_count;\n                if (is_stroke)\n                {\n                    State param_50 = st;\n                    path_cubic.stroke = get_linewidth(param_50);\n                }\n                else\n                {\n                    path_cubic.stroke = vec2(0.0);\n                }\n                path_out_ref = PathSegRef(_2435.conf.pathseg_alloc.offset + ((st.pathseg_count - 1u) * 52u));\n                param_51.offset = _2435.conf.pathseg_alloc.offset;\n                PathSegRef param_52 = path_out_ref;\n                uint param_53 = fill_mode;\n                PathCubic param_54 = path_cubic;\n                PathSeg_Cubic_write(param_51, param_52, param_53, param_54);\n                break;\n            }\n            case 3u:\n            {\n                ElementRef param_55 = this_ref;\n                CubicSeg cubic = Element_Cubic_read(param_55);\n                path_cubic.p0 = cubic.p0;\n                path_cubic.p1 = cubic.p1;\n                path_cubic.p2 = cubic.p2;\n                path_cubic.p3 = cubic.p3;\n                path_cubic.path_ix = st.path_count;\n                path_cubic.trans_ix = st.trans_count;\n                if (is_stroke)\n                {\n                    State param_56 = st;\n                    path_cubic.stroke = get_linewidth(param_56);\n                }\n                else\n                {\n                    path_cubic.stroke = vec2(0.0);\n                }\n                path_out_ref = PathSegRef(_2435.conf.pathseg_alloc.offset + ((st.pathseg_count - 1u) * 52u));\n                param_57.offset = _2435.conf.pathseg_alloc.offset;\n                PathSegRef param_58 = path_out_ref;\n                uint param_59 = fill_mode;\n                PathCubic param_60 = path_cubic;\n                PathSeg_Cubic_write(param_57, param_58, param_59, param_60);\n                break;\n            }\n            case 4u:\n            {\n                ElementRef param_61 = this_ref;\n                FillColor fill = Element_FillColor_read(param_61);\n                anno_fill.rgba_color = fill.rgba_color;\n                if (is_stroke)\n                {\n                    State param_62 = st;\n                    vec2 lw = get_linewidth(param_62);\n                    anno_fill.bbox = st.bbox + vec4(-lw, lw);\n                    anno_fill.linewidth = st.linewidth * sqrt(abs((st.mat.x * st.mat.w) - (st.mat.y * st.mat.z)));\n                }\n                else\n                {\n                    anno_fill.bbox = st.bbox;\n                    anno_fill.linewidth = 0.0;\n                }\n                out_ref = AnnotatedRef(_2435.conf.anno_alloc.offset + ((st.path_count - 1u) * 32u));\n                param_63.offset = _2435.conf.anno_alloc.offset;\n                AnnotatedRef param_64 = out_ref;\n                uint param_65 = fill_mode;\n                AnnoColor param_66 = anno_fill;\n                Annotated_Color_write(param_63, param_64, param_65, param_66);\n                break;\n            }\n            case 9u:\n            {\n                ElementRef param_67 = this_ref;\n                FillImage fill_img = Element_FillImage_read(param_67);\n                anno_img.index = fill_img.index;\n                anno_img.offset = fill_img.offset;\n                if (is_stroke)\n                {\n                    State param_68 = st;\n                    vec2 lw_1 = get_linewidth(param_68);\n                    anno_img.bbox = st.bbox + vec4(-lw_1, lw_1);\n                    anno_img.linewidth = st.linewidth * sqrt(abs((st.mat.x * st.mat.w) - (st.mat.y * st.mat.z)));\n                }\n                else\n                {\n                    anno_img.bbox = st.bbox;\n                    anno_img.linewidth = 0.0;\n                }\n                out_ref = AnnotatedRef(_2435.conf.anno_alloc.offset + ((st.path_count - 1u) * 32u));\n                param_69.offset = _2435.conf.anno_alloc.offset;\n                AnnotatedRef param_70 = out_ref;\n                uint param_71 = fill_mode;\n                AnnoImage param_72 = anno_img;\n                Annotated_Image_write(param_69, param_70, param_71, param_72);\n                break;\n            }\n            case 7u:\n            {\n                ElementRef param_73 = this_ref;\n                Clip begin_clip = Element_BeginClip_read(param_73);\n                if (is_stroke)\n                {\n                    State param_74 = st;\n                    vec2 lw_2 = get_linewidth(param_74);\n                    anno_begin_clip.bbox = begin_clip.bbox + vec4(-lw_2, lw_2);\n                    anno_begin_clip.linewidth = st.linewidth * sqrt(abs((st.mat.x * st.mat.w) - (st.mat.y * st.mat.z)));\n                }\n                else\n                {\n                    anno_begin_clip.bbox = begin_clip.bbox;\n                    anno_fill.linewidth = 0.0;\n                }\n                out_ref = AnnotatedRef(_2435.conf.anno_alloc.offset + ((st.path_count - 1u) * 32u));\n                param_75.offset = _2435.conf.anno_alloc.offset;\n                AnnotatedRef param_76 = out_ref;\n                uint param_77 = fill_mode;\n                AnnoBeginClip param_78 = anno_begin_clip;\n                Annotated_BeginClip_write(param_75, param_76, param_77, param_78);\n                break;\n            }\n            case 8u:\n            {\n                ElementRef param_79 = this_ref;\n                Clip end_clip = Element_EndClip_read(param_79);\n                AnnoEndClip anno_end_clip = AnnoEndClip(end_clip.bbox);\n                out_ref = AnnotatedRef(_2435.conf.anno_alloc.offset + ((st.path_count - 1u) * 32u));\n                param_80.offset = _2435.conf.anno_alloc.offset;\n                AnnotatedRef param_81 = out_ref;\n                AnnoEndClip param_82 = anno_end_clip;\n                Annotated_EndClip_write(param_80, param_81, param_82);\n                break;\n            }\n            case 6u:\n            {\n                TransformSeg transform = TransformSeg(st.mat, st.translate);\n                TransformSegRef trans_ref = TransformSegRef(_2435.conf.trans_alloc.offset + ((st.trans_count - 1u) * 24u));\n                param_83.offset = _2435.conf.trans_alloc.offset;\n                TransformSegRef param_84 = trans_ref;\n                TransformSeg param_85 = transform;\n                TransformSeg_write(param_83, param_84, param_85);\n                break;\n            }\n        }\n    }\n}\n\n",
	}
	shader_intersect_frag = driver.ShaderSources{
		Name:      "intersect.frag",
		Textures:  []driver.TextureBinding{{Name: "cover", Binding: 0}},
		GLSL100ES: "precision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D cover;\n\nvarying highp vec2 vUV;\n\nvoid main()\n{\n    float cover_1 = abs(texture2D(cover, vUV).x);\n    gl_FragData[0].x = cover_1;\n}\n\n",
		GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D cover;\n\nin highp vec2 vUV;\nlayout(location = 0) out vec4 fragColor;\n\nvoid main()\n{\n    float cover_1 = abs(texture(cover, vUV).x);\n    fragColor.x = cover_1;\n}\n\n",
		GLSL130:   "#version 130\n\nuniform sampler2D cover;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nvoid main()\n{\n    float cover_1 = abs(texture(cover, vUV).x);\n    fragColor.x = cover_1;\n}\n\n",
		GLSL150:   "#version 150\n\nuniform sampler2D cover;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nvoid main()\n{\n    float cover_1 = abs(texture(cover, vUV).x);\n    fragColor.x = cover_1;\n}\n\n",
		HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0xe0, 0xe4, 0x3, 0x8c, 0xac, 0x56, 0x46, 0x82, 0x6c, 0xe7, 0x7c, 0xc3, 0x54, 0xa6, 0x27, 0xef, 0x1, 0x0, 0x0, 0x0, 0x8, 0x3, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xd4, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0xfc, 0x1, 0x0, 0x0, 0xa0, 0x2, 0x0, 0x0, 0xd4, 0x2, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x94, 0x0, 0x0, 0x0, 0x94, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x6c, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x28, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x51, 0x0, 0x0, 0x5, 0x0, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x3, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x0, 0x8, 0xe4, 0xa0, 0x23, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xe, 0x80, 0x0, 0x0, 0x0, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0xa4, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x29, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x6, 0x12, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xe2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x71, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6b, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x5f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
	}
	shader_intersect_vert = driver.ShaderSources{
		Name:   "intersect.vert",
		Inputs: []driver.InputLocation{{Name: "pos", Location: 0, Semantic: "POSITION", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "NORMAL", SemanticIndex: 0, Type: 0x0, Size: 2}},
		Uniforms: driver.UniformsReflection{
			Blocks:    []driver.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []driver.UniformLocation{{Name: "_78.uvTransform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_78.subUVTransform", Type: 0x0, Size: 4, Offset: 16}},
			Size:      32,
		},
		GLSL100ES: "\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 uvTransform;\n    vec4 subUVTransform;\n};\n\nuniform Block _78;\n\nattribute vec2 pos;\nattribute vec2 uv;\nvarying vec2 vUV;\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));\n    vec3 param_1 = vec3(pos, 1.0);\n    vec3 p = transform3x2(param, param_1);\n    gl_Position = vec4(p, 1.0);\n    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_3 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_2, param_3);\n    vUV = (uv3.xy * _78.subUVTransform.xy) + _78.subUVTransform.zw;\n    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_5 = vec3(vUV, 1.0);\n    vUV = transform3x2(param_4, param_5).xy;\n    vUV = (vUV * _78.uvTransform.xy) + _78.uvTransform.zw;\n}\n\n",
		GLSL300ES: "#version 300 es\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nlayout(std140) uniform Block\n{\n    vec4 uvTransform;\n    vec4 subUVTransform;\n} _78;\n\nlayout(location = 0) in vec2 pos;\nlayout(location = 1) in vec2 uv;\nout vec2 vUV;\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));\n    vec3 param_1 = vec3(pos, 1.0);\n    vec3 p = transform3x2(param, param_1);\n    gl_Position = vec4(p, 1.0);\n    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_3 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_2, param_3);\n    vUV = (uv3.xy * _78.subUVTransform.xy) + _78.subUVTransform.zw;\n    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_5 = vec3(vUV, 1.0);\n    vUV = transform3x2(param_4, param_5).xy;\n    vUV = (vUV * _78.uvTransform.xy) + _78.uvTransform.zw;\n}\n\n",
		GLSL130:   "#version 130\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 uvTransform;\n    vec4 subUVTransform;\n};\n\nuniform Block _78;\n\nin vec2 pos;\nin vec2 uv;\nout vec2 vUV;\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));\n    vec3 param_1 = vec3(pos, 1.0);\n    vec3 p = transform3x2(param, param_1);\n    gl_Position = vec4(p, 1.0);\n    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_3 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_2, param_3);\n    vUV = (uv3.xy * _78.subUVTransform.xy) + _78.subUVTransform.zw;\n    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_5 = vec3(vUV, 1.0);\n    vUV = transform3x2(param_4, param_5).xy;\n    vUV = (vUV * _78.uvTransform.xy) + _78.uvTransform.zw;\n}\n\n",
		GLSL150:   "#version 150\n\nstruct m3x2\n{\n    vec3 r0;\n    vec3 r1;\n};\n\nstruct Block\n{\n    vec4 uvTransform;\n    vec4 subUVTransform;\n};\n\nuniform Block _78;\n\nin vec2 pos;\nin vec2 uv;\nout vec2 vUV;\n\nvec3 transform3x2(m3x2 t, vec3 v)\n{\n    return vec3(dot(t.r0, v), dot(t.r1, v), dot(vec3(0.0, 0.0, 1.0), v));\n}\n\nvoid main()\n{\n    m3x2 param = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));\n    vec3 param_1 = vec3(pos, 1.0);\n    vec3 p = transform3x2(param, param_1);\n    gl_Position = vec4(p, 1.0);\n    m3x2 param_2 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_3 = vec3(uv, 1.0);\n    vec3 uv3 = transform3x2(param_2, param_3);\n    vUV = (uv3.xy * _78.subUVTransform.xy) + _78.subUVTransform.zw;\n    m3x2 param_4 = m3x2(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 param_5 = vec3(vUV, 1.0);\n    vUV = transform3x2(param_4, param_5).xy;\n    vUV = (vUV * _78.uvTransform.xy) + _78.uvTransform.zw;\n}\n\n",
		HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0x27, 0x8, 0x9f, 0xbf, 0x30, 0xa, 0x5b, 0x38, 0xe, 0x78, 0x0, 0x22, 0xdb, 0x3b, 0x30, 0x54, 0x1, 0x0, 0x0, 0x0, 0xd8, 0x4, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x4c, 0x1, 0x0, 0x0, 0xc4, 0x2, 0x0, 0x0, 0x40, 0x3, 0x0, 0x0, 0x30, 0x4, 0x0, 0x0, 0x80, 0x4, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0xc, 0x1, 0x0, 0x0, 0xc, 0x1, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0xd8, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x1, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x51, 0x0, 0x0, 0x5, 0x3, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x1, 0x80, 0x1, 0x0, 0xf, 0x90, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x1, 0x0, 0x55, 0x90, 0x3, 0x0, 0xe4, 0xa0, 0x3, 0x0, 0xe1, 0xa0, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x3, 0x0, 0xe2, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x90, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x2, 0x0, 0xe4, 0xa0, 0x2, 0x0, 0xee, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x4, 0x80, 0x3, 0x0, 0x0, 0xa0, 0x8, 0x0, 0x0, 0x3, 0x0, 0x0, 0x8, 0x80, 0x3, 0x0, 0xc9, 0xa0, 0x0, 0x0, 0xe4, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0xe0, 0x0, 0x0, 0xec, 0x80, 0x1, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0xee, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0xc0, 0x0, 0x0, 0xe4, 0x90, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xc, 0xc0, 0x3, 0x0, 0x0, 0xa0, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x70, 0x1, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x36, 0x0, 0x0, 0x5, 0x52, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x56, 0x14, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0xa, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0xa, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0xf, 0x0, 0x0, 0xa, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x96, 0x5, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xc2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0xa, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xe8, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x0, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xac, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x37, 0x38, 0x5f, 0x75, 0x76, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x37, 0x38, 0x5f, 0x73, 0x75, 0x62, 0x55, 0x56, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x48, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x50, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0xab, 0xab, 0xab},
	}
	shader_kernel4_comp = driver.ShaderSources{
		Name:      "kernel4.comp",
		GLSL310ES: "#version 310 es\nlayout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;\n\nstruct Alloc\n{\n    uint offset;\n};\n\nstruct CmdStrokeRef\n{\n    uint offset;\n};\n\nstruct CmdStroke\n{\n    uint tile_ref;\n    float half_width;\n};\n\nstruct CmdFillRef\n{\n    uint offset;\n};\n\nstruct CmdFill\n{\n    uint tile_ref;\n    int backdrop;\n};\n\nstruct CmdColorRef\n{\n    uint offset;\n};\n\nstruct CmdColor\n{\n    uint rgba_color;\n};\n\nstruct CmdImageRef\n{\n    uint offset;\n};\n\nstruct CmdImage\n{\n    uint index;\n    ivec2 offset;\n};\n\nstruct CmdAlphaRef\n{\n    uint offset;\n};\n\nstruct CmdAlpha\n{\n    float alpha;\n};\n\nstruct CmdJumpRef\n{\n    uint offset;\n};\n\nstruct CmdJump\n{\n    uint new_ref;\n};\n\nstruct CmdRef\n{\n    uint offset;\n};\n\nstruct CmdTag\n{\n    uint tag;\n    uint flags;\n};\n\nstruct TileSegRef\n{\n    uint offset;\n};\n\nstruct TileSeg\n{\n    vec2 origin;\n    vec2 vector;\n    float y_edge;\n    TileSegRef next;\n};\n\nstruct Config\n{\n    uint n_elements;\n    uint n_pathseg;\n    uint width_in_tiles;\n    uint height_in_tiles;\n    Alloc tile_alloc;\n    Alloc bin_alloc;\n    Alloc ptcl_alloc;\n    Alloc pathseg_alloc;\n    Alloc anno_alloc;\n    Alloc trans_alloc;\n};\n\nlayout(binding = 0, std430) buffer Memory\n{\n    uint mem_offset;\n    uint mem_error;\n    uint memory[];\n} _196;\n\nlayout(binding = 1, std430) readonly buffer ConfigBuf\n{\n    Config conf;\n} _693;\n\nlayout(binding = 3, rgba8) uniform readonly highp image2D images[1];\nlayout(binding = 2, rgba8) uniform writeonly highp image2D image;\n\nAlloc new_alloc(uint offset, uint size)\n{\n    Alloc a;\n    a.offset = offset;\n    return a;\n}\n\nAlloc slice_mem(Alloc a, uint offset, uint size)\n{\n    uint param = a.offset + offset;\n    uint param_1 = size;\n    return new_alloc(param, param_1);\n}\n\nbool touch_mem(Alloc alloc, uint offset)\n{\n    return true;\n}\n\nuint read_mem(Alloc alloc, uint offset)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return 0u;\n    }\n    uint v = _196.memory[offset];\n    return v;\n}\n\nAlloc alloc_read(Alloc a, uint offset)\n{\n    Alloc param = a;\n    uint param_1 = offset >> uint(2);\n    Alloc alloc;\n    alloc.offset = read_mem(param, param_1);\n    return alloc;\n}\n\nCmdTag Cmd_tag(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint tag_and_flags = read_mem(param, param_1);\n    return CmdTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));\n}\n\nCmdStroke CmdStroke_read(Alloc a, CmdStrokeRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    CmdStroke s;\n    s.tile_ref = raw0;\n    s.half_width = uintBitsToFloat(raw1);\n    return s;\n}\n\nCmdStroke Cmd_Stroke_read(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    CmdStrokeRef param_1 = CmdStrokeRef(ref.offset + 4u);\n    return CmdStroke_read(param, param_1);\n}\n\nTileSeg TileSeg_read(Alloc a, TileSegRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 3u;\n    uint raw3 = read_mem(param_6, param_7);\n    Alloc param_8 = a;\n    uint param_9 = ix + 4u;\n    uint raw4 = read_mem(param_8, param_9);\n    Alloc param_10 = a;\n    uint param_11 = ix + 5u;\n    uint raw5 = read_mem(param_10, param_11);\n    TileSeg s;\n    s.origin = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\n    s.vector = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    s.y_edge = uintBitsToFloat(raw4);\n    s.next = TileSegRef(raw5);\n    return s;\n}\n\nuvec2 chunk_offset(uint i)\n{\n    return uvec2((i % 2u) * 16u, (i / 2u) * 8u);\n}\n\nCmdFill CmdFill_read(Alloc a, CmdFillRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    CmdFill s;\n    s.tile_ref = raw0;\n    s.backdrop = int(raw1);\n    return s;\n}\n\nCmdFill Cmd_Fill_read(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    CmdFillRef param_1 = CmdFillRef(ref.offset + 4u);\n    return CmdFill_read(param, param_1);\n}\n\nCmdAlpha CmdAlpha_read(Alloc a, CmdAlphaRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    CmdAlpha s;\n    s.alpha = uintBitsToFloat(raw0);\n    return s;\n}\n\nCmdAlpha Cmd_Alpha_read(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    CmdAlphaRef param_1 = CmdAlphaRef(ref.offset + 4u);\n    return CmdAlpha_read(param, param_1);\n}\n\nCmdColor CmdColor_read(Alloc a, CmdColorRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    CmdColor s;\n    s.rgba_color = raw0;\n    return s;\n}\n\nCmdColor Cmd_Color_read(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    CmdColorRef param_1 = CmdColorRef(ref.offset + 4u);\n    return CmdColor_read(param, param_1);\n}\n\nvec3 fromsRGB(vec3 srgb)\n{\n    bvec3 cutoff = greaterThanEqual(srgb, vec3(0.040449999272823333740234375));\n    vec3 below = srgb / vec3(12.9200000762939453125);\n    vec3 above = pow((srgb + vec3(0.054999999701976776123046875)) / vec3(1.05499994754791259765625), vec3(2.400000095367431640625));\n    return mix(below, above, cutoff);\n}\n\nvec4 unpacksRGB(uint srgba)\n{\n    vec4 color = unpackUnorm4x8(srgba).wzyx;\n    vec3 param = color.xyz;\n    return vec4(fromsRGB(param), color.w);\n}\n\nCmdImage CmdImage_read(Alloc a, CmdImageRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    CmdImage s;\n    s.index = raw0;\n    s.offset = ivec2(int(raw1 << uint(16)) >> 16, int(raw1) >> 16);\n    return s;\n}\n\nCmdImage Cmd_Image_read(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    CmdImageRef param_1 = CmdImageRef(ref.offset + 4u);\n    return CmdImage_read(param, param_1);\n}\n\nvec4[8] fillImage(uvec2 xy, CmdImage cmd_img)\n{\n    vec4 rgba[8];\n    for (uint i = 0u; i < 8u; i++)\n    {\n        uint param = i;\n        ivec2 uv = ivec2(xy + chunk_offset(param)) + cmd_img.offset;\n        vec4 fg_rgba = imageLoad(images[0], uv);\n        vec3 param_1 = fg_rgba.xyz;\n        vec3 _663 = fromsRGB(param_1);\n        fg_rgba = vec4(_663.x, _663.y, _663.z, fg_rgba.w);\n        rgba[i] = fg_rgba;\n    }\n    return rgba;\n}\n\nvec3 tosRGB(vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));\n    vec3 below = vec3(12.9200000762939453125) * rgb;\n    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);\n    return mix(below, above, cutoff);\n}\n\nuint packsRGB(inout vec4 rgba)\n{\n    vec3 param = rgba.xyz;\n    rgba = vec4(tosRGB(param), rgba.w);\n    return packUnorm4x8(rgba.wzyx);\n}\n\nvoid write_mem(Alloc alloc, uint offset, uint val)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return;\n    }\n    _196.memory[offset] = val;\n}\n\nCmdJump CmdJump_read(Alloc a, CmdJumpRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    CmdJump s;\n    s.new_ref = raw0;\n    return s;\n}\n\nCmdJump Cmd_Jump_read(Alloc a, CmdRef ref)\n{\n    Alloc param = a;\n    CmdJumpRef param_1 = CmdJumpRef(ref.offset + 4u);\n    return CmdJump_read(param, param_1);\n}\n\nvoid main()\n{\n    if (_196.mem_error != 0u)\n    {\n        return;\n    }\n    uint tile_ix = (gl_WorkGroupID.y * _693.conf.width_in_tiles) + gl_WorkGroupID.x;\n    Alloc param;\n    param.offset = _693.conf.ptcl_alloc.offset;\n    uint param_1 = tile_ix * 1024u;\n    uint param_2 = 1024u;\n    Alloc cmd_alloc = slice_mem(param, param_1, param_2);\n    CmdRef cmd_ref = CmdRef(cmd_alloc.offset);\n    Alloc param_3 = cmd_alloc;\n    uint param_4 = cmd_ref.offset;\n    Alloc scratch_alloc = alloc_read(param_3, param_4);\n    cmd_ref.offset += 8u;\n    uvec2 xy_uint = uvec2(gl_LocalInvocationID.x + (32u * gl_WorkGroupID.x), gl_LocalInvocationID.y + (32u * gl_WorkGroupID.y));\n    vec2 xy = vec2(xy_uint);\n    vec4 rgba[8];\n    for (uint i = 0u; i < 8u; i++)\n    {\n        rgba[i] = vec4(0.0);\n    }\n    uint clip_depth = 0u;\n    float df[8];\n    TileSegRef tile_seg_ref;\n    float area[8];\n    uint base_ix;\n    while (true)\n    {\n        Alloc param_5 = cmd_alloc;\n        CmdRef param_6 = cmd_ref;\n        uint tag = Cmd_tag(param_5, param_6).tag;\n        if (tag == 0u)\n        {\n            break;\n        }\n        switch (tag)\n        {\n            case 2u:\n            {\n                Alloc param_7 = cmd_alloc;\n                CmdRef param_8 = cmd_ref;\n                CmdStroke stroke = Cmd_Stroke_read(param_7, param_8);\n                for (uint k = 0u; k < 8u; k++)\n                {\n                    df[k] = 1000000000.0;\n                }\n                tile_seg_ref = TileSegRef(stroke.tile_ref);\n                do\n                {\n                    uint param_9 = tile_seg_ref.offset;\n                    uint param_10 = 24u;\n                    Alloc param_11 = new_alloc(param_9, param_10);\n                    TileSegRef param_12 = tile_seg_ref;\n                    TileSeg seg = TileSeg_read(param_11, param_12);\n                    vec2 line_vec = seg.vector;\n                    for (uint k_1 = 0u; k_1 < 8u; k_1++)\n                    {\n                        vec2 dpos = (xy + vec2(0.5)) - seg.origin;\n                        uint param_13 = k_1;\n                        dpos += vec2(chunk_offset(param_13));\n                        float t = clamp(dot(line_vec, dpos) / dot(line_vec, line_vec), 0.0, 1.0);\n                        df[k_1] = min(df[k_1], length((line_vec * t) - dpos));\n                    }\n                    tile_seg_ref = seg.next;\n                } while (tile_seg_ref.offset != 0u);\n                for (uint k_2 = 0u; k_2 < 8u; k_2++)\n                {\n                    area[k_2] = clamp((stroke.half_width + 0.5) - df[k_2], 0.0, 1.0);\n                }\n                cmd_ref.offset += 12u;\n                break;\n            }\n            case 1u:\n            {\n                Alloc param_14 = cmd_alloc;\n                CmdRef param_15 = cmd_ref;\n                CmdFill fill = Cmd_Fill_read(param_14, param_15);\n                for (uint k_3 = 0u; k_3 < 8u; k_3++)\n                {\n                    area[k_3] = float(fill.backdrop);\n                }\n                tile_seg_ref = TileSegRef(fill.tile_ref);\n                do\n                {\n                    uint param_16 = tile_seg_ref.offset;\n                    uint param_17 = 24u;\n                    Alloc param_18 = new_alloc(param_16, param_17);\n                    TileSegRef param_19 = tile_seg_ref;\n                    TileSeg seg_1 = TileSeg_read(param_18, param_19);\n                    for (uint k_4 = 0u; k_4 < 8u; k_4++)\n                    {\n                        uint param_20 = k_4;\n                        vec2 my_xy = xy + vec2(chunk_offset(param_20));\n                        vec2 start = seg_1.origin - my_xy;\n                        vec2 end = start + seg_1.vector;\n                        vec2 window = clamp(vec2(start.y, end.y), vec2(0.0), vec2(1.0));\n                        if (!(window.x == window.y))\n                        {\n                            vec2 t_1 = (window - vec2(start.y)) / vec2(seg_1.vector.y);\n                            vec2 xs = vec2(mix(start.x, end.x, t_1.x), mix(start.x, end.x, t_1.y));\n                            float xmin = min(min(xs.x, xs.y), 1.0) - 9.9999999747524270787835121154785e-07;\n                            float xmax = max(xs.x, xs.y);\n                            float b = min(xmax, 1.0);\n                            float c = max(b, 0.0);\n                            float d = max(xmin, 0.0);\n                            float a = ((b + (0.5 * ((d * d) - (c * c)))) - xmin) / (xmax - xmin);\n                            area[k_4] += (a * (window.x - window.y));\n                        }\n                        area[k_4] += (sign(seg_1.vector.x) * clamp((my_xy.y - seg_1.y_edge) + 1.0, 0.0, 1.0));\n                    }\n                    tile_seg_ref = seg_1.next;\n                } while (tile_seg_ref.offset != 0u);\n                for (uint k_5 = 0u; k_5 < 8u; k_5++)\n                {\n                    area[k_5] = min(abs(area[k_5]), 1.0);\n                }\n                cmd_ref.offset += 12u;\n                break;\n            }\n            case 3u:\n            {\n                for (uint k_6 = 0u; k_6 < 8u; k_6++)\n                {\n                    area[k_6] = 1.0;\n                }\n                cmd_ref.offset += 4u;\n                break;\n            }\n            case 4u:\n            {\n                Alloc param_21 = cmd_alloc;\n                CmdRef param_22 = cmd_ref;\n                CmdAlpha alpha = Cmd_Alpha_read(param_21, param_22);\n                for (uint k_7 = 0u; k_7 < 8u; k_7++)\n                {\n                    area[k_7] = alpha.alpha;\n                }\n                cmd_ref.offset += 8u;\n                break;\n            }\n            case 5u:\n            {\n                Alloc param_23 = cmd_alloc;\n                CmdRef param_24 = cmd_ref;\n                CmdColor color = Cmd_Color_read(param_23, param_24);\n                uint param_25 = color.rgba_color;\n                vec4 fg = unpacksRGB(param_25);\n                for (uint k_8 = 0u; k_8 < 8u; k_8++)\n                {\n                    vec4 fg_k = fg * area[k_8];\n                    rgba[k_8] = (rgba[k_8] * (1.0 - fg_k.w)) + fg_k;\n                }\n                cmd_ref.offset += 8u;\n                break;\n            }\n            case 6u:\n            {\n                Alloc param_26 = cmd_alloc;\n                CmdRef param_27 = cmd_ref;\n                CmdImage fill_img = Cmd_Image_read(param_26, param_27);\n                uvec2 param_28 = xy_uint;\n                CmdImage param_29 = fill_img;\n                vec4 img[8] = fillImage(param_28, param_29);\n                for (uint k_9 = 0u; k_9 < 8u; k_9++)\n                {\n                    vec4 fg_k_1 = img[k_9] * area[k_9];\n                    rgba[k_9] = (rgba[k_9] * (1.0 - fg_k_1.w)) + fg_k_1;\n                }\n                cmd_ref.offset += 12u;\n                break;\n            }\n            case 7u:\n            {\n                base_ix = (scratch_alloc.offset >> uint(2)) + (2u * ((((clip_depth * 32u) * 32u) + gl_LocalInvocationID.x) + (32u * gl_LocalInvocationID.y)));\n                for (uint k_10 = 0u; k_10 < 8u; k_10++)\n                {\n                    uint param_30 = k_10;\n                    uvec2 offset = chunk_offset(param_30);\n                    vec4 param_31 = vec4(rgba[k_10]);\n                    uint _1286 = packsRGB(param_31);\n                    uint srgb = _1286;\n                    float alpha_1 = clamp(abs(area[k_10]), 0.0, 1.0);\n                    Alloc param_32 = scratch_alloc;\n                    uint param_33 = (base_ix + 0u) + (2u * (offset.x + (offset.y * 32u)));\n                    uint param_34 = srgb;\n                    write_mem(param_32, param_33, param_34);\n                    Alloc param_35 = scratch_alloc;\n                    uint param_36 = (base_ix + 1u) + (2u * (offset.x + (offset.y * 32u)));\n                    uint param_37 = floatBitsToUint(alpha_1);\n                    write_mem(param_35, param_36, param_37);\n                    rgba[k_10] = vec4(0.0);\n                }\n                clip_depth++;\n                cmd_ref.offset += 4u;\n                break;\n            }\n            case 8u:\n            {\n                clip_depth--;\n                base_ix = (scratch_alloc.offset >> uint(2)) + (2u * ((((clip_depth * 32u) * 32u) + gl_LocalInvocationID.x) + (32u * gl_LocalInvocationID.y)));\n                for (uint k_11 = 0u; k_11 < 8u; k_11++)\n                {\n                    uint param_38 = k_11;\n                    uvec2 offset_1 = chunk_offset(param_38);\n                    Alloc param_39 = scratch_alloc;\n                    uint param_40 = (base_ix + 0u) + (2u * (offset_1.x + (offset_1.y * 32u)));\n                    uint srgb_1 = read_mem(param_39, param_40);\n                    Alloc param_41 = scratch_alloc;\n                    uint param_42 = (base_ix + 1u) + (2u * (offset_1.x + (offset_1.y * 32u)));\n                    uint alpha_2 = read_mem(param_41, param_42);\n                    uint param_43 = srgb_1;\n                    vec4 bg = unpacksRGB(param_43);\n                    vec4 fg_1 = (rgba[k_11] * area[k_11]) * uintBitsToFloat(alpha_2);\n                    rgba[k_11] = (bg * (1.0 - fg_1.w)) + fg_1;\n                }\n                cmd_ref.offset += 4u;\n                break;\n            }\n            case 9u:\n            {\n                Alloc param_44 = cmd_alloc;\n                CmdRef param_45 = cmd_ref;\n                cmd_ref = CmdRef(Cmd_Jump_read(param_44, param_45).new_ref);\n                cmd_alloc.offset = cmd_ref.offset;\n                continue;\n            }\n        }\n    }\n    for (uint i_1 = 0u; i_1 < 8u; i_1++)\n    {\n        uint param_46 = i_1;\n        vec3 param_47 = rgba[i_1].xyz;\n        imageStore(image, ivec2(xy_uint + chunk_offset(param_46)), vec4(tosRGB(param_47), rgba[i_1].w));\n    }\n}\n\n",
	}
	shader_material_frag = driver.ShaderSources{
		Name:      "material.frag",
		Textures:  []driver.TextureBinding{{Name: "tex", Binding: 0}},
		GLSL100ES: "precision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\n\nvarying vec2 vUV;\n\nvec3 RGBtosRGB(vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));\n    vec3 below = vec3(12.9200000762939453125) * rgb;\n    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);\n    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);\n}\n\nvoid main()\n{\n    vec4 texel = texture2D(tex, vUV);\n    highp vec3 param = texel.xyz;\n    vec3 _59 = RGBtosRGB(param);\n    texel = vec4(_59.x, _59.y, _59.z, texel.w);\n    gl_FragData[0] = texel;\n}\n\n",
		GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nuniform mediump sampler2D tex;\n\nin vec2 vUV;\nlayout(location = 0) out vec4 fragColor;\n\nvec3 RGBtosRGB(vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));\n    vec3 below = vec3(12.9200000762939453125) * rgb;\n    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);\n    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);\n}\n\nvoid main()\n{\n    vec4 texel = texture(tex, vUV);\n    highp vec3 param = texel.xyz;\n    vec3 _59 = RGBtosRGB(param);\n    texel = vec4(_59.x, _59.y, _59.z, texel.w);\n    fragColor = texel;\n}\n\n",
		GLSL130:   "#version 130\n\nuniform sampler2D tex;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nvec3 RGBtosRGB(vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));\n    vec3 below = vec3(12.9200000762939453125) * rgb;\n    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);\n    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);\n}\n\nvoid main()\n{\n    vec4 texel = texture(tex, vUV);\n    vec3 param = texel.xyz;\n    vec3 _59 = RGBtosRGB(param);\n    texel = vec4(_59.x, _59.y, _59.z, texel.w);\n    fragColor = texel;\n}\n\n",
		GLSL150:   "#version 150\n\nuniform sampler2D tex;\n\nin vec2 vUV;\nout vec4 fragColor;\n\nvec3 RGBtosRGB(vec3 rgb)\n{\n    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.003130800090730190277099609375));\n    vec3 below = vec3(12.9200000762939453125) * rgb;\n    vec3 above = (vec3(1.05499994754791259765625) * pow(rgb, vec3(0.416660010814666748046875))) - vec3(0.054999999701976776123046875);\n    return vec3(cutoff.x ? above.x : below.x, cutoff.y ? above.y : below.y, cutoff.z ? above.z : below.z);\n}\n\nvoid main()\n{\n    vec4 texel = texture(tex, vUV);\n    vec3 param = texel.xyz;\n    vec3 _59 = RGBtosRGB(param);\n    texel = vec4(_59.x, _59.y, _59.z, texel.w);\n    fragColor = texel;\n}\n\n",
		HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0x9e, 0x87, 0x4c, 0x44, 0xf3, 0x17, 0xa, 0x6, 0x5c, 0xb7, 0x98, 0x94, 0xa9, 0x50, 0x4b, 0x65, 0x1, 0x0, 0x0, 0x0, 0xc8, 0x4, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xbc, 0x1, 0x0, 0x0, 0x44, 0x3, 0x0, 0x0, 0xc0, 0x3, 0x0, 0x0, 0x60, 0x4, 0x0, 0x0, 0x94, 0x4, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x7c, 0x1, 0x0, 0x0, 0x7c, 0x1, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x54, 0x1, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x28, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x51, 0x0, 0x0, 0x5, 0x0, 0x0, 0xf, 0xa0, 0x3d, 0xa, 0x87, 0x3f, 0xae, 0x47, 0x61, 0xbd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x51, 0x0, 0x0, 0x5, 0x1, 0x0, 0xf, 0xa0, 0x1c, 0x2e, 0x4d, 0xbb, 0x52, 0xb8, 0x4e, 0x41, 0x76, 0x54, 0xd5, 0x3e, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x3, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x8, 0xf, 0xa0, 0x42, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0x0, 0x8, 0xe4, 0xa0, 0xf, 0x0, 0x0, 0x2, 0x1, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x80, 0xf, 0x0, 0x0, 0x2, 0x1, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0xf, 0x0, 0x0, 0x2, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x5, 0x0, 0x0, 0x3, 0x1, 0x0, 0x7, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x1, 0x0, 0xaa, 0xa0, 0xe, 0x0, 0x0, 0x2, 0x2, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x80, 0xe, 0x0, 0x0, 0x2, 0x2, 0x0, 0x2, 0x80, 0x1, 0x0, 0x55, 0x80, 0xe, 0x0, 0x0, 0x2, 0x2, 0x0, 0x4, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0x7, 0x80, 0x2, 0x0, 0xe4, 0x80, 0x0, 0x0, 0x0, 0xa0, 0x0, 0x0, 0x55, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x8, 0x80, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0xa0, 0x5, 0x0, 0x0, 0x3, 0x2, 0x0, 0x7, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x1, 0x0, 0x55, 0xa0, 0x58, 0x0, 0x0, 0x4, 0x0, 0x0, 0x1, 0x80, 0x1, 0x0, 0xff, 0x80, 0x1, 0x0, 0x0, 0x80, 0x2, 0x0, 0x0, 0x80, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x1, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0x0, 0xa0, 0x58, 0x0, 0x0, 0x4, 0x0, 0x0, 0x2, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0x55, 0x80, 0x2, 0x0, 0x55, 0x80, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x1, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x1, 0x0, 0x0, 0xa0, 0x58, 0x0, 0x0, 0x4, 0x0, 0x0, 0x4, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x2, 0x0, 0xaa, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x80, 0x1, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x3, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2f, 0x0, 0x0, 0x5, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x76, 0x54, 0xd5, 0x3e, 0x76, 0x54, 0xd5, 0x3e, 0x76, 0x54, 0xd5, 0x3e, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x5, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xf, 0x72, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x3d, 0xa, 0x87, 0x3f, 0x3d, 0xa, 0x87, 0x3f, 0x3d, 0xa, 0x87, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0xae, 0x47, 0x61, 0xbd, 0xae, 0x47, 0x61, 0xbd, 0xae, 0x47, 0x61, 0xbd, 0x0, 0x0, 0x0, 0x0, 0x1d, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x1c, 0x2e, 0x4d, 0x3b, 0x1c, 0x2e, 0x4d, 0x3b, 0x1c, 0x2e, 0x4d, 0x3b, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0xa, 0x72, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x52, 0xb8, 0x4e, 0x41, 0x52, 0xb8, 0x4e, 0x41, 0x52, 0xb8, 0x4e, 0x41, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x82, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x37, 0x0, 0x0, 0x9, 0x72, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0xa, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x98, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x6d, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x69, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0x5f, 0x74, 0x65, 0x78, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x0, 0x74, 0x65, 0x78, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
	}
	shader_material_vert = driver.ShaderSources{
		Name:      "material.vert",
		Inputs:    []driver.InputLocation{{Name: "pos", Location: 0, Semantic: "POSITION", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "uv", Location: 1, Semantic: "NORMAL", SemanticIndex: 0, Type: 0x0, Size: 2}},
		GLSL100ES: "\nvarying vec2 vUV;\nattribute vec2 uv;\nattribute vec2 pos;\n\nvoid main()\n{\n    vUV = uv;\n    gl_Position = vec4(pos, 0.0, 1.0);\n}\n\n",
		GLSL300ES: "#version 300 es\n\nout vec2 vUV;\nlayout(location = 1) in vec2 uv;\nlayout(location = 0) in vec2 pos;\n\nvoid main()\n{\n    vUV = uv;\n    gl_Position = vec4(pos, 0.0, 1.0);\n}\n\n",
		GLSL130:   "#version 130\n\nout vec2 vUV;\nin vec2 uv;\nin vec2 pos;\n\nvoid main()\n{\n    vUV = uv;\n    gl_Position = vec4(pos, 0.0, 1.0);\n}\n\n",
		GLSL150:   "#version 150\n\nout vec2 vUV;\nin vec2 uv;\nin vec2 pos;\n\nvoid main()\n{\n    vUV = uv;\n    gl_Position = vec4(pos, 0.0, 1.0);\n}\n\n",
		HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0x31, 0x5e, 0x57, 0x9, 0xf5, 0x54, 0x6e, 0x41, 0xea, 0x62, 0x61, 0x8a, 0x9c, 0x49, 0xdf, 0xf8, 0x1, 0x0, 0x0, 0x0, 0xc8, 0x2, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0xc8, 0x0, 0x0, 0x0, 0x58, 0x1, 0x0, 0x0, 0xd4, 0x1, 0x0, 0x0, 0x20, 0x2, 0x0, 0x0, 0x70, 0x2, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x88, 0x0, 0x0, 0x0, 0x88, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x60, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x51, 0x0, 0x0, 0x5, 0x1, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x1, 0x80, 0x1, 0x0, 0xf, 0x90, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0xc0, 0x0, 0x0, 0xe4, 0x90, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x3, 0xe0, 0x1, 0x0, 0xe4, 0x90, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xc, 0xc0, 0x1, 0x0, 0x44, 0xa0, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x88, 0x0, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x22, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xc2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x48, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x50, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0xab, 0xab, 0xab},
	}
	shader_path_coarse_comp = driver.ShaderSources{
		Name:      "path_coarse.comp",
		GLSL310ES: "#version 310 es\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;\n\nstruct Alloc\n{\n    uint offset;\n};\n\nstruct MallocResult\n{\n    Alloc alloc;\n    bool failed;\n};\n\nstruct PathCubicRef\n{\n    uint offset;\n};\n\nstruct PathCubic\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n    vec2 p3;\n    uint path_ix;\n    uint trans_ix;\n    vec2 stroke;\n};\n\nstruct PathSegRef\n{\n    uint offset;\n};\n\nstruct PathSegTag\n{\n    uint tag;\n    uint flags;\n};\n\nstruct TileRef\n{\n    uint offset;\n};\n\nstruct PathRef\n{\n    uint offset;\n};\n\nstruct Path\n{\n    uvec4 bbox;\n    TileRef tiles;\n};\n\nstruct TileSegRef\n{\n    uint offset;\n};\n\nstruct TileSeg\n{\n    vec2 origin;\n    vec2 vector;\n    float y_edge;\n    TileSegRef next;\n};\n\nstruct TransformSegRef\n{\n    uint offset;\n};\n\nstruct TransformSeg\n{\n    vec4 mat;\n    vec2 translate;\n};\n\nstruct SubdivResult\n{\n    float val;\n    float a0;\n    float a2;\n};\n\nstruct Config\n{\n    uint n_elements;\n    uint n_pathseg;\n    uint width_in_tiles;\n    uint height_in_tiles;\n    Alloc tile_alloc;\n    Alloc bin_alloc;\n    Alloc ptcl_alloc;\n    Alloc pathseg_alloc;\n    Alloc anno_alloc;\n    Alloc trans_alloc;\n};\n\nlayout(binding = 0, std430) buffer Memory\n{\n    uint mem_offset;\n    uint mem_error;\n    uint memory[];\n} _149;\n\nlayout(binding = 1, std430) readonly buffer ConfigBuf\n{\n    Config conf;\n} _788;\n\nbool touch_mem(Alloc alloc, uint offset)\n{\n    return true;\n}\n\nuint read_mem(Alloc alloc, uint offset)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return 0u;\n    }\n    uint v = _149.memory[offset];\n    return v;\n}\n\nPathSegTag PathSeg_tag(Alloc a, PathSegRef ref)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint tag_and_flags = read_mem(param, param_1);\n    return PathSegTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));\n}\n\nPathCubic PathCubic_read(Alloc a, PathCubicRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 3u;\n    uint raw3 = read_mem(param_6, param_7);\n    Alloc param_8 = a;\n    uint param_9 = ix + 4u;\n    uint raw4 = read_mem(param_8, param_9);\n    Alloc param_10 = a;\n    uint param_11 = ix + 5u;\n    uint raw5 = read_mem(param_10, param_11);\n    Alloc param_12 = a;\n    uint param_13 = ix + 6u;\n    uint raw6 = read_mem(param_12, param_13);\n    Alloc param_14 = a;\n    uint param_15 = ix + 7u;\n    uint raw7 = read_mem(param_14, param_15);\n    Alloc param_16 = a;\n    uint param_17 = ix + 8u;\n    uint raw8 = read_mem(param_16, param_17);\n    Alloc param_18 = a;\n    uint param_19 = ix + 9u;\n    uint raw9 = read_mem(param_18, param_19);\n    Alloc param_20 = a;\n    uint param_21 = ix + 10u;\n    uint raw10 = read_mem(param_20, param_21);\n    Alloc param_22 = a;\n    uint param_23 = ix + 11u;\n    uint raw11 = read_mem(param_22, param_23);\n    PathCubic s;\n    s.p0 = vec2(uintBitsToFloat(raw0), uintBitsToFloat(raw1));\n    s.p1 = vec2(uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    s.p2 = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\n    s.p3 = vec2(uintBitsToFloat(raw6), uintBitsToFloat(raw7));\n    s.path_ix = raw8;\n    s.trans_ix = raw9;\n    s.stroke = vec2(uintBitsToFloat(raw10), uintBitsToFloat(raw11));\n    return s;\n}\n\nPathCubic PathSeg_Cubic_read(Alloc a, PathSegRef ref)\n{\n    Alloc param = a;\n    PathCubicRef param_1 = PathCubicRef(ref.offset + 4u);\n    return PathCubic_read(param, param_1);\n}\n\nTransformSeg TransformSeg_read(Alloc a, TransformSegRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 3u;\n    uint raw3 = read_mem(param_6, param_7);\n    Alloc param_8 = a;\n    uint param_9 = ix + 4u;\n    uint raw4 = read_mem(param_8, param_9);\n    Alloc param_10 = a;\n    uint param_11 = ix + 5u;\n    uint raw5 = read_mem(param_10, param_11);\n    TransformSeg s;\n    s.mat = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    s.translate = vec2(uintBitsToFloat(raw4), uintBitsToFloat(raw5));\n    return s;\n}\n\nvec2 eval_cubic(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t)\n{\n    float mt = 1.0 - t;\n    return (p0 * ((mt * mt) * mt)) + (((p1 * ((mt * mt) * 3.0)) + (((p2 * (mt * 3.0)) + (p3 * t)) * t)) * t);\n}\n\nfloat approx_parabola_integral(float x)\n{\n    return x * inversesqrt(sqrt(0.3300000131130218505859375 + (0.201511204242706298828125 + ((0.25 * x) * x))));\n}\n\nSubdivResult estimate_subdiv(vec2 p0, vec2 p1, vec2 p2, float sqrt_tol)\n{\n    vec2 d01 = p1 - p0;\n    vec2 d12 = p2 - p1;\n    vec2 dd = d01 - d12;\n    float _cross = ((p2.x - p0.x) * dd.y) - ((p2.y - p0.y) * dd.x);\n    float x0 = ((d01.x * dd.x) + (d01.y * dd.y)) / _cross;\n    float x2 = ((d12.x * dd.x) + (d12.y * dd.y)) / _cross;\n    float scale = abs(_cross / (length(dd) * (x2 - x0)));\n    float param = x0;\n    float a0 = approx_parabola_integral(param);\n    float param_1 = x2;\n    float a2 = approx_parabola_integral(param_1);\n    float val = 0.0;\n    if (scale < 1000000000.0)\n    {\n        float da = abs(a2 - a0);\n        float sqrt_scale = sqrt(scale);\n        if (sign(x0) == sign(x2))\n        {\n            val = da * sqrt_scale;\n        }\n        else\n        {\n            float xmin = sqrt_tol / sqrt_scale;\n            float param_2 = xmin;\n            val = (sqrt_tol * da) / approx_parabola_integral(param_2);\n        }\n    }\n    return SubdivResult(val, a0, a2);\n}\n\nuint fill_mode_from_flags(uint flags)\n{\n    return flags & 1u;\n}\n\nPath Path_read(Alloc a, PathRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Path s;\n    s.bbox = uvec4(raw0 & 65535u, raw0 >> uint(16), raw1 & 65535u, raw1 >> uint(16));\n    s.tiles = TileRef(raw2);\n    return s;\n}\n\nAlloc new_alloc(uint offset, uint size)\n{\n    Alloc a;\n    a.offset = offset;\n    return a;\n}\n\nfloat approx_parabola_inv_integral(float x)\n{\n    return x * sqrt(0.61000001430511474609375 + (0.1520999968051910400390625 + ((0.25 * x) * x)));\n}\n\nvec2 eval_quad(vec2 p0, vec2 p1, vec2 p2, float t)\n{\n    float mt = 1.0 - t;\n    return (p0 * (mt * mt)) + (((p1 * (mt * 2.0)) + (p2 * t)) * t);\n}\n\nMallocResult malloc(uint size)\n{\n    MallocResult r;\n    r.failed = false;\n    uint _155 = atomicAdd(_149.mem_offset, size);\n    uint offset = _155;\n    uint param = offset;\n    uint param_1 = size;\n    r.alloc = new_alloc(param, param_1);\n    if ((offset + size) > uint(int(uint(_149.memory.length())) * 4))\n    {\n        r.failed = true;\n        uint _176 = atomicMax(_149.mem_error, 1u);\n        return r;\n    }\n    return r;\n}\n\nTileRef Tile_index(TileRef ref, uint index)\n{\n    return TileRef(ref.offset + (index * 8u));\n}\n\nvoid write_mem(Alloc alloc, uint offset, uint val)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return;\n    }\n    _149.memory[offset] = val;\n}\n\nvoid TileSeg_write(Alloc a, TileSegRef ref, TileSeg s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = floatBitsToUint(s.origin.x);\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = floatBitsToUint(s.origin.y);\n    write_mem(param_3, param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 2u;\n    uint param_8 = floatBitsToUint(s.vector.x);\n    write_mem(param_6, param_7, param_8);\n    Alloc param_9 = a;\n    uint param_10 = ix + 3u;\n    uint param_11 = floatBitsToUint(s.vector.y);\n    write_mem(param_9, param_10, param_11);\n    Alloc param_12 = a;\n    uint param_13 = ix + 4u;\n    uint param_14 = floatBitsToUint(s.y_edge);\n    write_mem(param_12, param_13, param_14);\n    Alloc param_15 = a;\n    uint param_16 = ix + 5u;\n    uint param_17 = s.next.offset;\n    write_mem(param_15, param_16, param_17);\n}\n\nvoid main()\n{\n    if (_149.mem_error != 0u)\n    {\n        return;\n    }\n    uint element_ix = gl_GlobalInvocationID.x;\n    PathSegRef ref = PathSegRef(_788.conf.pathseg_alloc.offset + (element_ix * 52u));\n    PathSegTag tag = PathSegTag(0u, 0u);\n    if (element_ix < _788.conf.n_pathseg)\n    {\n        Alloc param;\n        param.offset = _788.conf.pathseg_alloc.offset;\n        PathSegRef param_1 = ref;\n        tag = PathSeg_tag(param, param_1);\n    }\n    switch (tag.tag)\n    {\n        case 1u:\n        {\n            Alloc param_2;\n            param_2.offset = _788.conf.pathseg_alloc.offset;\n            PathSegRef param_3 = ref;\n            PathCubic cubic = PathSeg_Cubic_read(param_2, param_3);\n            uint trans_ix = cubic.trans_ix;\n            if (trans_ix > 0u)\n            {\n                TransformSegRef trans_ref = TransformSegRef(_788.conf.trans_alloc.offset + ((trans_ix - 1u) * 24u));\n                Alloc param_4;\n                param_4.offset = _788.conf.trans_alloc.offset;\n                TransformSegRef param_5 = trans_ref;\n                TransformSeg trans = TransformSeg_read(param_4, param_5);\n                cubic.p0 = ((trans.mat.xy * cubic.p0.x) + (trans.mat.zw * cubic.p0.y)) + trans.translate;\n                cubic.p1 = ((trans.mat.xy * cubic.p1.x) + (trans.mat.zw * cubic.p1.y)) + trans.translate;\n                cubic.p2 = ((trans.mat.xy * cubic.p2.x) + (trans.mat.zw * cubic.p2.y)) + trans.translate;\n                cubic.p3 = ((trans.mat.xy * cubic.p3.x) + (trans.mat.zw * cubic.p3.y)) + trans.translate;\n            }\n            vec2 err_v = (((cubic.p2 - cubic.p1) * 3.0) + cubic.p0) - cubic.p3;\n            float err = (err_v.x * err_v.x) + (err_v.y * err_v.y);\n            uint n_quads = max(uint(ceil(pow(err * 3.7037036418914794921875, 0.16666667163372039794921875))), 1u);\n            float val = 0.0;\n            vec2 qp0 = cubic.p0;\n            float _step = 1.0 / float(n_quads);\n            for (uint i = 0u; i < n_quads; i++)\n            {\n                float t = float(i + 1u) * _step;\n                vec2 param_6 = cubic.p0;\n                vec2 param_7 = cubic.p1;\n                vec2 param_8 = cubic.p2;\n                vec2 param_9 = cubic.p3;\n                float param_10 = t;\n                vec2 qp2 = eval_cubic(param_6, param_7, param_8, param_9, param_10);\n                vec2 param_11 = cubic.p0;\n                vec2 param_12 = cubic.p1;\n                vec2 param_13 = cubic.p2;\n                vec2 param_14 = cubic.p3;\n                float param_15 = t - (0.5 * _step);\n                vec2 qp1 = eval_cubic(param_11, param_12, param_13, param_14, param_15);\n                qp1 = (qp1 * 2.0) - ((qp0 + qp2) * 0.5);\n                vec2 param_16 = qp0;\n                vec2 param_17 = qp1;\n                vec2 param_18 = qp2;\n                float param_19 = 0.4743416607379913330078125;\n                SubdivResult params = estimate_subdiv(param_16, param_17, param_18, param_19);\n                val += params.val;\n                qp0 = qp2;\n            }\n            uint n = max(uint(ceil((val * 0.5) / 0.4743416607379913330078125)), 1u);\n            uint param_20 = tag.flags;\n            bool is_stroke = fill_mode_from_flags(param_20) == 1u;\n            uint path_ix = cubic.path_ix;\n            Alloc param_21;\n            param_21.offset = _788.conf.tile_alloc.offset;\n            PathRef param_22 = PathRef(_788.conf.tile_alloc.offset + (path_ix * 12u));\n            Path path = Path_read(param_21, param_22);\n            uint param_23 = path.tiles.offset;\n            uint param_24 = ((path.bbox.z - path.bbox.x) * (path.bbox.w - path.bbox.y)) * 8u;\n            Alloc path_alloc = new_alloc(param_23, param_24);\n            ivec4 bbox = ivec4(path.bbox);\n            vec2 p0 = cubic.p0;\n            qp0 = cubic.p0;\n            float v_step = val / float(n);\n            int n_out = 1;\n            float val_sum = 0.0;\n            vec2 p1;\n            float _1309;\n            TileSeg tile_seg;\n            for (uint i_1 = 0u; i_1 < n_quads; i_1++)\n            {\n                float t_1 = float(i_1 + 1u) * _step;\n                vec2 param_25 = cubic.p0;\n                vec2 param_26 = cubic.p1;\n                vec2 param_27 = cubic.p2;\n                vec2 param_28 = cubic.p3;\n                float param_29 = t_1;\n                vec2 qp2_1 = eval_cubic(param_25, param_26, param_27, param_28, param_29);\n                vec2 param_30 = cubic.p0;\n                vec2 param_31 = cubic.p1;\n                vec2 param_32 = cubic.p2;\n                vec2 param_33 = cubic.p3;\n                float param_34 = t_1 - (0.5 * _step);\n                vec2 qp1_1 = eval_cubic(param_30, param_31, param_32, param_33, param_34);\n                qp1_1 = (qp1_1 * 2.0) - ((qp0 + qp2_1) * 0.5);\n                vec2 param_35 = qp0;\n                vec2 param_36 = qp1_1;\n                vec2 param_37 = qp2_1;\n                float param_38 = 0.4743416607379913330078125;\n                SubdivResult params_1 = estimate_subdiv(param_35, param_36, param_37, param_38);\n                float param_39 = params_1.a0;\n                float u0 = approx_parabola_inv_integral(param_39);\n                float param_40 = params_1.a2;\n                float u2 = approx_parabola_inv_integral(param_40);\n                float uscale = 1.0 / (u2 - u0);\n                float target = float(n_out) * v_step;\n                for (;;)\n                {\n                    bool _1202 = uint(n_out) == n;\n                    bool _1212;\n                    if (!_1202)\n                    {\n                        _1212 = target < (val_sum + params_1.val);\n                    }\n                    else\n                    {\n                        _1212 = _1202;\n                    }\n                    if (_1212)\n                    {\n                        if (uint(n_out) == n)\n                        {\n                            p1 = cubic.p3;\n                        }\n                        else\n                        {\n                            float u = (target - val_sum) / params_1.val;\n                            float a = mix(params_1.a0, params_1.a2, u);\n                            float param_41 = a;\n                            float au = approx_parabola_inv_integral(param_41);\n                            float t_2 = (au - u0) * uscale;\n                            vec2 param_42 = qp0;\n                            vec2 param_43 = qp1_1;\n                            vec2 param_44 = qp2_1;\n                            float param_45 = t_2;\n                            p1 = eval_quad(param_42, param_43, param_44, param_45);\n                        }\n                        float xmin = min(p0.x, p1.x) - cubic.stroke.x;\n                        float xmax = max(p0.x, p1.x) + cubic.stroke.x;\n                        float ymin = min(p0.y, p1.y) - cubic.stroke.y;\n                        float ymax = max(p0.y, p1.y) + cubic.stroke.y;\n                        float dx = p1.x - p0.x;\n                        float dy = p1.y - p0.y;\n                        if (abs(dy) < 9.999999717180685365747194737196e-10)\n                        {\n                            _1309 = 1000000000.0;\n                        }\n                        else\n                        {\n                            _1309 = dx / dy;\n                        }\n                        float invslope = _1309;\n                        float c = (cubic.stroke.x + (abs(invslope) * (16.0 + cubic.stroke.y))) * 0.03125;\n                        float b = invslope;\n                        float a_1 = (p0.x - ((p0.y - 16.0) * b)) * 0.03125;\n                        int x0 = int(floor(xmin * 0.03125));\n                        int x1 = int(floor(xmax * 0.03125) + 1.0);\n                        int y0 = int(floor(ymin * 0.03125));\n                        int y1 = int(floor(ymax * 0.03125) + 1.0);\n                        x0 = clamp(x0, bbox.x, bbox.z);\n                        y0 = clamp(y0, bbox.y, bbox.w);\n                        x1 = clamp(x1, bbox.x, bbox.z);\n                        y1 = clamp(y1, bbox.y, bbox.w);\n                        float xc = a_1 + (b * float(y0));\n                        int stride = bbox.z - bbox.x;\n                        int base = ((y0 - bbox.y) * stride) - bbox.x;\n                        uint n_tile_alloc = uint((x1 - x0) * (y1 - y0));\n                        uint param_46 = n_tile_alloc * 24u;\n                        MallocResult _1424 = malloc(param_46);\n                        MallocResult tile_alloc = _1424;\n                        if (tile_alloc.failed)\n                        {\n                            return;\n                        }\n                        uint tile_offset = tile_alloc.alloc.offset;\n                        int xray = int(floor(p0.x * 0.03125));\n                        int last_xray = int(floor(p1.x * 0.03125));\n                        if (p0.y > p1.y)\n                        {\n                            int tmp = xray;\n                            xray = last_xray;\n                            last_xray = tmp;\n                        }\n                        for (int y = y0; y < y1; y++)\n                        {\n                            float tile_y0 = float(y * 32);\n                            int xbackdrop = max((xray + 1), bbox.x);\n                            bool _1478 = !is_stroke;\n                            bool _1488;\n                            if (_1478)\n                            {\n                                _1488 = min(p0.y, p1.y) < tile_y0;\n                            }\n                            else\n                            {\n                                _1488 = _1478;\n                            }\n                            bool _1495;\n                            if (_1488)\n                            {\n                                _1495 = xbackdrop < bbox.z;\n                            }\n                            else\n                            {\n                                _1495 = _1488;\n                            }\n                            if (_1495)\n                            {\n                                int backdrop = (p1.y < p0.y) ? 1 : (-1);\n                                TileRef param_47 = path.tiles;\n                                uint param_48 = uint(base + xbackdrop);\n                                TileRef tile_ref = Tile_index(param_47, param_48);\n                                uint tile_el = tile_ref.offset >> uint(2);\n                                Alloc param_49 = path_alloc;\n                                uint param_50 = tile_el + 1u;\n                                if (touch_mem(param_49, param_50))\n                                {\n                                    uint _1533 = atomicAdd(_149.memory[tile_el + 1u], uint(backdrop));\n                                }\n                            }\n                            int next_xray = last_xray;\n                            if (y < (y1 - 1))\n                            {\n                                float tile_y1 = float((y + 1) * 32);\n                                float x_edge = mix(p0.x, p1.x, (tile_y1 - p0.y) / dy);\n                                next_xray = int(floor(x_edge * 0.03125));\n                            }\n                            int min_xray = min(xray, next_xray);\n                            int max_xray = max(xray, next_xray);\n                            int xx0 = min(int(floor(xc - c)), min_xray);\n                            int xx1 = max(int(ceil(xc + c)), (max_xray + 1));\n                            xx0 = clamp(xx0, x0, x1);\n                            xx1 = clamp(xx1, x0, x1);\n                            for (int x = xx0; x < xx1; x++)\n                            {\n                                float tile_x0 = float(x * 32);\n                                TileRef param_51 = TileRef(path.tiles.offset);\n                                uint param_52 = uint(base + x);\n                                TileRef tile_ref_1 = Tile_index(param_51, param_52);\n                                uint tile_el_1 = tile_ref_1.offset >> uint(2);\n                                uint old = 0u;\n                                Alloc param_53 = path_alloc;\n                                uint param_54 = tile_el_1;\n                                if (touch_mem(param_53, param_54))\n                                {\n                                    uint _1636 = atomicExchange(_149.memory[tile_el_1], tile_offset);\n                                    old = _1636;\n                                }\n                                tile_seg.origin = p0;\n                                tile_seg.vector = p1 - p0;\n                                float y_edge = 0.0;\n                                if (!is_stroke)\n                                {\n                                    y_edge = mix(p0.y, p1.y, (tile_x0 - p0.x) / dx);\n                                    if (min(p0.x, p1.x) < tile_x0)\n                                    {\n                                        vec2 p = vec2(tile_x0, y_edge);\n                                        if (p0.x > p1.x)\n                                        {\n                                            tile_seg.vector = p - p0;\n                                        }\n                                        else\n                                        {\n                                            tile_seg.origin = p;\n                                            tile_seg.vector = p1 - p;\n                                        }\n                                        if (tile_seg.vector.x == 0.0)\n                                        {\n                                            tile_seg.vector.x = sign(p1.x - p0.x) * 9.999999717180685365747194737196e-10;\n                                        }\n                                    }\n                                    if ((x <= min_xray) || (max_xray < x))\n                                    {\n                                        y_edge = 1000000000.0;\n                                    }\n                                }\n                                tile_seg.y_edge = y_edge;\n                                tile_seg.next.offset = old;\n                                Alloc param_55 = tile_alloc.alloc;\n                                TileSegRef param_56 = TileSegRef(tile_offset);\n                                TileSeg param_57 = tile_seg;\n                                TileSeg_write(param_55, param_56, param_57);\n                                tile_offset += 24u;\n                            }\n                            xc += b;\n                            base += stride;\n                            xray = next_xray;\n                        }\n                        n_out++;\n                        target += v_step;\n                        p0 = p1;\n                        continue;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                val_sum += params_1.val;\n                qp0 = qp2_1;\n            }\n            break;\n        }\n    }\n}\n\n",
	}
	shader_stencil_frag = driver.ShaderSources{
		Name:      "stencil.frag",
		GLSL100ES: "precision mediump float;\nprecision highp int;\n\nvarying vec2 vTo;\nvarying vec2 vFrom;\nvarying vec2 vCtrl;\n\nvoid main()\n{\n    float dx = vTo.x - vFrom.x;\n    bool increasing = vTo.x >= vFrom.x;\n    bvec2 _35 = bvec2(increasing);\n    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);\n    bvec2 _41 = bvec2(increasing);\n    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);\n    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));\n    float midx = mix(extent.x, extent.y, 0.5);\n    float x0 = midx - left.x;\n    vec2 p1 = vCtrl - left;\n    vec2 v = right - vCtrl;\n    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));\n    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);\n    vec2 d_half = mix(p1, v, vec2(t));\n    float dy = d_half.y / d_half.x;\n    float width = extent.y - extent.x;\n    dy = abs(dy * width);\n    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);\n    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));\n    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));\n    area *= width;\n    if (width == 0.0)\n    {\n        area = 0.0;\n    }\n    gl_FragData[0].x = area;\n}\n\n",
		GLSL300ES: "#version 300 es\nprecision mediump float;\nprecision highp int;\n\nin vec2 vTo;\nin vec2 vFrom;\nin vec2 vCtrl;\nlayout(location = 0) out vec4 fragCover;\n\nvoid main()\n{\n    float dx = vTo.x - vFrom.x;\n    bool increasing = vTo.x >= vFrom.x;\n    bvec2 _35 = bvec2(increasing);\n    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);\n    bvec2 _41 = bvec2(increasing);\n    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);\n    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));\n    float midx = mix(extent.x, extent.y, 0.5);\n    float x0 = midx - left.x;\n    vec2 p1 = vCtrl - left;\n    vec2 v = right - vCtrl;\n    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));\n    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);\n    vec2 d_half = mix(p1, v, vec2(t));\n    float dy = d_half.y / d_half.x;\n    float width = extent.y - extent.x;\n    dy = abs(dy * width);\n    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);\n    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));\n    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));\n    area *= width;\n    if (width == 0.0)\n    {\n        area = 0.0;\n    }\n    fragCover.x = area;\n}\n\n",
		GLSL130:   "#version 130\n\nin vec2 vTo;\nin vec2 vFrom;\nin vec2 vCtrl;\nout vec4 fragCover;\n\nvoid main()\n{\n    float dx = vTo.x - vFrom.x;\n    bool increasing = vTo.x >= vFrom.x;\n    bvec2 _35 = bvec2(increasing);\n    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);\n    bvec2 _41 = bvec2(increasing);\n    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);\n    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));\n    float midx = mix(extent.x, extent.y, 0.5);\n    float x0 = midx - left.x;\n    vec2 p1 = vCtrl - left;\n    vec2 v = right - vCtrl;\n    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));\n    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);\n    vec2 d_half = mix(p1, v, vec2(t));\n    float dy = d_half.y / d_half.x;\n    float width = extent.y - extent.x;\n    dy = abs(dy * width);\n    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);\n    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));\n    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));\n    area *= width;\n    if (width == 0.0)\n    {\n        area = 0.0;\n    }\n    fragCover.x = area;\n}\n\n",
		GLSL150:   "#version 150\n\nin vec2 vTo;\nin vec2 vFrom;\nin vec2 vCtrl;\nout vec4 fragCover;\n\nvoid main()\n{\n    float dx = vTo.x - vFrom.x;\n    bool increasing = vTo.x >= vFrom.x;\n    bvec2 _35 = bvec2(increasing);\n    vec2 left = vec2(_35.x ? vFrom.x : vTo.x, _35.y ? vFrom.y : vTo.y);\n    bvec2 _41 = bvec2(increasing);\n    vec2 right = vec2(_41.x ? vTo.x : vFrom.x, _41.y ? vTo.y : vFrom.y);\n    vec2 extent = clamp(vec2(vFrom.x, vTo.x), vec2(-0.5), vec2(0.5));\n    float midx = mix(extent.x, extent.y, 0.5);\n    float x0 = midx - left.x;\n    vec2 p1 = vCtrl - left;\n    vec2 v = right - vCtrl;\n    float t = x0 / (p1.x + sqrt((p1.x * p1.x) + ((v.x - p1.x) * x0)));\n    float y = mix(mix(left.y, vCtrl.y, t), mix(vCtrl.y, right.y, t), t);\n    vec2 d_half = mix(p1, v, vec2(t));\n    float dy = d_half.y / d_half.x;\n    float width = extent.y - extent.x;\n    dy = abs(dy * width);\n    vec4 sides = vec4((dy * 0.5) + y, (dy * (-0.5)) + y, (0.5 - y) / dy, ((-0.5) - y) / dy);\n    sides = clamp(sides + vec4(0.5), vec4(0.0), vec4(1.0));\n    float area = 0.5 * ((((sides.z - (sides.z * sides.y)) + 1.0) - sides.x) + (sides.x * sides.w));\n    area *= width;\n    if (width == 0.0)\n    {\n        area = 0.0;\n    }\n    fragCover.x = area;\n}\n\n",
		HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0x94, 0x21, 0xb9, 0x13, 0x4c, 0xba, 0xd, 0x11, 0x8f, 0xc7, 0xce, 0xe, 0x41, 0x73, 0xec, 0xe1, 0x1, 0x0, 0x0, 0x0, 0x5c, 0xa, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x9c, 0x3, 0x0, 0x0, 0xfc, 0x8, 0x0, 0x0, 0x78, 0x9, 0x0, 0x0, 0xc4, 0x9, 0x0, 0x0, 0x28, 0xa, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0x5c, 0x3, 0x0, 0x0, 0x5c, 0x3, 0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x38, 0x3, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x2, 0xff, 0xff, 0x51, 0x0, 0x0, 0x5, 0x0, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0xb0, 0x1f, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x3, 0xb0, 0xb, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0xb0, 0x0, 0x0, 0x0, 0xa0, 0xb, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x1, 0x0, 0x0, 0xb0, 0x0, 0x0, 0x0, 0xa0, 0xa, 0x0, 0x0, 0x3, 0x1, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x0, 0x0, 0x55, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x81, 0x1, 0x0, 0x55, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x55, 0xa0, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0x3, 0x80, 0x0, 0x0, 0xe4, 0xb0, 0xa, 0x0, 0x0, 0x3, 0x2, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0xb0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x2, 0x0, 0x0, 0x81, 0xb, 0x0, 0x0, 0x3, 0x3, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0xb0, 0x1, 0x0, 0x0, 0x80, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x4, 0x80, 0x1, 0x0, 0x0, 0x81, 0x1, 0x0, 0x0, 0xb0, 0x58, 0x0, 0x0, 0x4, 0x3, 0x0, 0x2, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x1, 0x0, 0x55, 0xb0, 0x1, 0x0, 0x55, 0x80, 0x58, 0x0, 0x0, 0x4, 0x2, 0x0, 0x2, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x1, 0x0, 0x55, 0x80, 0x1, 0x0, 0x55, 0xb0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0xc, 0x80, 0x3, 0x0, 0x1b, 0x80, 0x0, 0x0, 0xe4, 0xb1, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x3, 0x80, 0x2, 0x0, 0xe4, 0x81, 0x0, 0x0, 0x1b, 0xb0, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0xff, 0x80, 0x1, 0x0, 0x0, 0x81, 0x5, 0x0, 0x0, 0x3, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0x4, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x7, 0x0, 0x0, 0x2, 0x1, 0x0, 0x4, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x6, 0x0, 0x0, 0x2, 0x1, 0x0, 0x4, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x4, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x1, 0x0, 0x0, 0x80, 0x6, 0x0, 0x0, 0x2, 0x1, 0x0, 0x4, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0x55, 0x80, 0x2, 0x0, 0x55, 0x80, 0x12, 0x0, 0x0, 0x4, 0x2, 0x0, 0x3, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x1b, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x4, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x0, 0x0, 0xaa, 0xb0, 0x12, 0x0, 0x0, 0x4, 0x2, 0x0, 0x4, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x6, 0x0, 0x0, 0x2, 0x0, 0x0, 0x2, 0x80, 0x2, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x2, 0x0, 0x55, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x55, 0x80, 0x23, 0x0, 0x0, 0x2, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0x1, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x55, 0xa0, 0x2, 0x0, 0xaa, 0x80, 0x4, 0x0, 0x0, 0x4, 0x1, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x0, 0xa0, 0x2, 0x0, 0xaa, 0x80, 0x6, 0x0, 0x0, 0x2, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0xc, 0x80, 0x2, 0x0, 0xaa, 0x81, 0x0, 0x0, 0x1b, 0xa0, 0x5, 0x0, 0x0, 0x3, 0x1, 0x0, 0x8, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0xff, 0x80, 0x5, 0x0, 0x0, 0x3, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0xaa, 0x80, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x1f, 0x80, 0x1, 0x0, 0xe4, 0x80, 0x0, 0x0, 0x55, 0xa0, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x2, 0x80, 0x1, 0x0, 0xaa, 0x80, 0x1, 0x0, 0x55, 0x81, 0x1, 0x0, 0xaa, 0x80, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0xaa, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x1, 0x0, 0x0, 0x81, 0x0, 0x0, 0x55, 0x80, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x2, 0x80, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0xff, 0x80, 0x0, 0x0, 0x55, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x80, 0x5, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x0, 0x0, 0x55, 0xa0, 0x58, 0x0, 0x0, 0x4, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x81, 0x0, 0x0, 0xff, 0xa0, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xe, 0x80, 0x0, 0x0, 0xff, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x8, 0xf, 0x80, 0x0, 0x0, 0xe4, 0x80, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x58, 0x5, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x56, 0x1, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0xc2, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x3, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0xa, 0x32, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0xa, 0x32, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x7, 0x32, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x7, 0x32, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x6, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1d, 0x0, 0x0, 0x7, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x37, 0x0, 0x0, 0x9, 0x42, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1a, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x37, 0x0, 0x0, 0x9, 0x42, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x72, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x2, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0xa6, 0x1b, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xc2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x56, 0x9, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa6, 0x1e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xb2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa6, 0xe, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x4b, 0x0, 0x0, 0x5, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0xc2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x56, 0xd, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa6, 0xe, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x7, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3a, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb, 0x32, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xd, 0x32, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0xa6, 0xa, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x8, 0xc2, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x6, 0x4, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa6, 0xa, 0x10, 0x80, 0x81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0xa, 0xf2, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x3f, 0x32, 0x0, 0x0, 0xa, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18, 0x0, 0x0, 0x7, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x37, 0x0, 0x0, 0x9, 0x12, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xe2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x29, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x5c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0xc, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab},
	}
	shader_stencil_vert = driver.ShaderSources{
		Name:   "stencil.vert",
		Inputs: []driver.InputLocation{{Name: "corner", Location: 0, Semantic: "POSITION", SemanticIndex: 0, Type: 0x0, Size: 1}, {Name: "maxy", Location: 1, Semantic: "NORMAL", SemanticIndex: 0, Type: 0x0, Size: 1}, {Name: "from", Location: 2, Semantic: "TEXCOORD", SemanticIndex: 0, Type: 0x0, Size: 2}, {Name: "ctrl", Location: 3, Semantic: "TEXCOORD", SemanticIndex: 1, Type: 0x0, Size: 2}, {Name: "to", Location: 4, Semantic: "TEXCOORD", SemanticIndex: 2, Type: 0x0, Size: 2}},
		Uniforms: driver.UniformsReflection{
			Blocks:    []driver.UniformBlock{{Name: "Block", Binding: 0}},
			Locations: []driver.UniformLocation{{Name: "_16.transform", Type: 0x0, Size: 4, Offset: 0}, {Name: "_16.pathOffset", Type: 0x0, Size: 2, Offset: 16}},
			Size:      24,
		},
		GLSL100ES: "\nstruct Block\n{\n    vec4 transform;\n    vec2 pathOffset;\n};\n\nuniform Block _16;\n\nattribute vec2 from;\nattribute vec2 ctrl;\nattribute vec2 to;\nattribute float maxy;\nattribute float corner;\nvarying vec2 vFrom;\nvarying vec2 vCtrl;\nvarying vec2 vTo;\n\nvoid main()\n{\n    vec2 from_1 = from + _16.pathOffset;\n    vec2 ctrl_1 = ctrl + _16.pathOffset;\n    vec2 to_1 = to + _16.pathOffset;\n    float maxy_1 = maxy + _16.pathOffset.y;\n    float c = corner;\n    vec2 pos;\n    if (c >= 0.375)\n    {\n        c -= 0.5;\n        pos.y = maxy_1 + 1.0;\n    }\n    else\n    {\n        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;\n    }\n    if (c >= 0.125)\n    {\n        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;\n    }\n    else\n    {\n        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;\n    }\n    vFrom = from_1 - pos;\n    vCtrl = ctrl_1 - pos;\n    vTo = to_1 - pos;\n    pos = (pos * _16.transform.xy) + _16.transform.zw;\n    gl_Position = vec4(pos, 1.0, 1.0);\n}\n\n",
		GLSL300ES: "#version 300 es\n\nlayout(std140) uniform Block\n{\n    vec4 transform;\n    vec2 pathOffset;\n} _16;\n\nlayout(location = 2) in vec2 from;\nlayout(location = 3) in vec2 ctrl;\nlayout(location = 4) in vec2 to;\nlayout(location = 1) in float maxy;\nlayout(location = 0) in float corner;\nout vec2 vFrom;\nout vec2 vCtrl;\nout vec2 vTo;\n\nvoid main()\n{\n    vec2 from_1 = from + _16.pathOffset;\n    vec2 ctrl_1 = ctrl + _16.pathOffset;\n    vec2 to_1 = to + _16.pathOffset;\n    float maxy_1 = maxy + _16.pathOffset.y;\n    float c = corner;\n    vec2 pos;\n    if (c >= 0.375)\n    {\n        c -= 0.5;\n        pos.y = maxy_1 + 1.0;\n    }\n    else\n    {\n        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;\n    }\n    if (c >= 0.125)\n    {\n        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;\n    }\n    else\n    {\n        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;\n    }\n    vFrom = from_1 - pos;\n    vCtrl = ctrl_1 - pos;\n    vTo = to_1 - pos;\n    pos = (pos * _16.transform.xy) + _16.transform.zw;\n    gl_Position = vec4(pos, 1.0, 1.0);\n}\n\n",
		GLSL130:   "#version 130\n\nstruct Block\n{\n    vec4 transform;\n    vec2 pathOffset;\n};\n\nuniform Block _16;\n\nin vec2 from;\nin vec2 ctrl;\nin vec2 to;\nin float maxy;\nin float corner;\nout vec2 vFrom;\nout vec2 vCtrl;\nout vec2 vTo;\n\nvoid main()\n{\n    vec2 from_1 = from + _16.pathOffset;\n    vec2 ctrl_1 = ctrl + _16.pathOffset;\n    vec2 to_1 = to + _16.pathOffset;\n    float maxy_1 = maxy + _16.pathOffset.y;\n    float c = corner;\n    vec2 pos;\n    if (c >= 0.375)\n    {\n        c -= 0.5;\n        pos.y = maxy_1 + 1.0;\n    }\n    else\n    {\n        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;\n    }\n    if (c >= 0.125)\n    {\n        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;\n    }\n    else\n    {\n        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;\n    }\n    vFrom = from_1 - pos;\n    vCtrl = ctrl_1 - pos;\n    vTo = to_1 - pos;\n    pos = (pos * _16.transform.xy) + _16.transform.zw;\n    gl_Position = vec4(pos, 1.0, 1.0);\n}\n\n",
		GLSL150:   "#version 150\n\nstruct Block\n{\n    vec4 transform;\n    vec2 pathOffset;\n};\n\nuniform Block _16;\n\nin vec2 from;\nin vec2 ctrl;\nin vec2 to;\nin float maxy;\nin float corner;\nout vec2 vFrom;\nout vec2 vCtrl;\nout vec2 vTo;\n\nvoid main()\n{\n    vec2 from_1 = from + _16.pathOffset;\n    vec2 ctrl_1 = ctrl + _16.pathOffset;\n    vec2 to_1 = to + _16.pathOffset;\n    float maxy_1 = maxy + _16.pathOffset.y;\n    float c = corner;\n    vec2 pos;\n    if (c >= 0.375)\n    {\n        c -= 0.5;\n        pos.y = maxy_1 + 1.0;\n    }\n    else\n    {\n        pos.y = min(min(from_1.y, ctrl_1.y), to_1.y) - 1.0;\n    }\n    if (c >= 0.125)\n    {\n        pos.x = max(max(from_1.x, ctrl_1.x), to_1.x) + 1.0;\n    }\n    else\n    {\n        pos.x = min(min(from_1.x, ctrl_1.x), to_1.x) - 1.0;\n    }\n    vFrom = from_1 - pos;\n    vCtrl = ctrl_1 - pos;\n    vTo = to_1 - pos;\n    pos = (pos * _16.transform.xy) + _16.transform.zw;\n    gl_Position = vec4(pos, 1.0, 1.0);\n}\n\n",
		HLSL:      []byte{0x44, 0x58, 0x42, 0x43, 0x99, 0xea, 0x97, 0xb5, 0xa8, 0xd5, 0x84, 0x5e, 0x4b, 0x12, 0x14, 0x56, 0xdd, 0xee, 0xfc, 0x44, 0x1, 0x0, 0x0, 0x0, 0x18, 0x8, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x4c, 0x2, 0x0, 0x0, 0x74, 0x5, 0x0, 0x0, 0xf0, 0x5, 0x0, 0x0, 0xec, 0x6, 0x0, 0x0, 0x90, 0x7, 0x0, 0x0, 0x41, 0x6f, 0x6e, 0x39, 0xc, 0x2, 0x0, 0x0, 0xc, 0x2, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0xd8, 0x1, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x1, 0x0, 0x24, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x24, 0x0, 0x1, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xfe, 0xff, 0x51, 0x0, 0x0, 0x5, 0x3, 0x0, 0xf, 0xa0, 0x0, 0x0, 0xc0, 0x3e, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x0, 0xbf, 0x51, 0x0, 0x0, 0x5, 0x4, 0x0, 0xf, 0xa0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x0, 0x80, 0x0, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x1, 0x80, 0x1, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x2, 0x80, 0x2, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x3, 0x80, 0x3, 0x0, 0xf, 0x90, 0x1f, 0x0, 0x0, 0x2, 0x5, 0x0, 0x4, 0x80, 0x4, 0x0, 0xf, 0x90, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x1, 0x0, 0x0, 0x90, 0x2, 0x0, 0x55, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x4, 0x80, 0x0, 0x0, 0x0, 0x80, 0x3, 0x0, 0x55, 0xa0, 0xd, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x90, 0x3, 0x0, 0x0, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0x4, 0x80, 0x0, 0x0, 0x0, 0x90, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x0, 0x90, 0x3, 0x0, 0xff, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x2, 0x0, 0x3, 0x80, 0x2, 0x0, 0xe4, 0x90, 0x2, 0x0, 0xe4, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x2, 0x0, 0xc, 0x80, 0x3, 0x0, 0x14, 0x90, 0x2, 0x0, 0x14, 0xa0, 0xa, 0x0, 0x0, 0x3, 0x3, 0x0, 0x3, 0x80, 0x2, 0x0, 0xee, 0x80, 0x2, 0x0, 0xe1, 0x80, 0x2, 0x0, 0x0, 0x3, 0x3, 0x0, 0xc, 0x80, 0x4, 0x0, 0x44, 0x90, 0x2, 0x0, 0x44, 0xa0, 0xa, 0x0, 0x0, 0x3, 0x3, 0x0, 0x3, 0x80, 0x3, 0x0, 0xeb, 0x80, 0x3, 0x0, 0xe4, 0x80, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x3, 0x80, 0x3, 0x0, 0xe4, 0x80, 0x3, 0x0, 0xaa, 0xa0, 0x12, 0x0, 0x0, 0x4, 0x4, 0x0, 0x6, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xe4, 0x80, 0x1, 0x0, 0xc8, 0x80, 0xd, 0x0, 0x0, 0x3, 0x0, 0x0, 0x1, 0x80, 0x4, 0x0, 0x55, 0x80, 0x4, 0x0, 0x0, 0xa0, 0xb, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x2, 0x0, 0xff, 0x80, 0x2, 0x0, 0x0, 0x80, 0xb, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x3, 0x0, 0xaa, 0x80, 0x0, 0x0, 0x55, 0x80, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x2, 0x80, 0x0, 0x0, 0x55, 0x80, 0x3, 0x0, 0x55, 0xa0, 0x12, 0x0, 0x0, 0x4, 0x4, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x55, 0x80, 0x1, 0x0, 0x55, 0x80, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf, 0xe0, 0x2, 0x0, 0xe4, 0x80, 0x4, 0x0, 0x28, 0x81, 0x2, 0x0, 0x0, 0x3, 0x1, 0x0, 0x3, 0xe0, 0x3, 0x0, 0xee, 0x80, 0x4, 0x0, 0xe8, 0x81, 0x4, 0x0, 0x0, 0x4, 0x0, 0x0, 0x3, 0x80, 0x4, 0x0, 0xe8, 0x80, 0x1, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0xee, 0xa0, 0x2, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0xc0, 0x0, 0x0, 0xe4, 0x80, 0x0, 0x0, 0xe4, 0xa0, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0xc, 0xc0, 0x3, 0x0, 0x55, 0xa0, 0xff, 0xff, 0x0, 0x0, 0x53, 0x48, 0x44, 0x52, 0x20, 0x3, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0xc8, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x12, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x12, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x4, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xc2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1a, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x42, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x1d, 0x0, 0x0, 0x7, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x3e, 0x0, 0x0, 0x0, 0x7, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbf, 0x36, 0x0, 0x0, 0x5, 0x42, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x32, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xc2, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x6, 0x14, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x6, 0x84, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x7, 0x32, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0xb6, 0xf, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x16, 0x5, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xc2, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x6, 0x14, 0x10, 0x0, 0x4, 0x0, 0x0, 0x0, 0x6, 0x84, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x7, 0x32, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0xb6, 0xf, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x32, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x80, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x37, 0x0, 0x0, 0x9, 0x62, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x56, 0x6, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa6, 0x8, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1d, 0x0, 0x0, 0x7, 0x22, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x34, 0x0, 0x0, 0x7, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0xa, 0x0, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x7, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x82, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x40, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x37, 0x0, 0x0, 0x9, 0x12, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3a, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x86, 0x8, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x32, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x86, 0x0, 0x10, 0x80, 0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0xa, 0x10, 0x0, 0x3, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xb, 0x32, 0x20, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x86, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x80, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6, 0x8a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x8, 0xc2, 0x20, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x3f, 0x0, 0x0, 0x80, 0x3f, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x16, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0x0, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xf4, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x0, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xac, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xbc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x36, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x0, 0xab, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x31, 0x36, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x0, 0xab, 0x1, 0x0, 0x3, 0x0, 0x1, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2e, 0x31, 0x0, 0x49, 0x53, 0x47, 0x4e, 0x9c, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x89, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x80, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x68, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x3, 0x0, 0x0, 0x68, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x71, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x0, 0xab, 0xab, 0xab},
	}
	shader_tile_alloc_comp = driver.ShaderSources{
		Name:      "tile_alloc.comp",
		GLSL310ES: "#version 310 es\nlayout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;\n\nstruct Alloc\n{\n    uint offset;\n};\n\nstruct MallocResult\n{\n    Alloc alloc;\n    bool failed;\n};\n\nstruct AnnoEndClipRef\n{\n    uint offset;\n};\n\nstruct AnnoEndClip\n{\n    vec4 bbox;\n};\n\nstruct AnnotatedRef\n{\n    uint offset;\n};\n\nstruct AnnotatedTag\n{\n    uint tag;\n    uint flags;\n};\n\nstruct PathRef\n{\n    uint offset;\n};\n\nstruct TileRef\n{\n    uint offset;\n};\n\nstruct Path\n{\n    uvec4 bbox;\n    TileRef tiles;\n};\n\nstruct Config\n{\n    uint n_elements;\n    uint n_pathseg;\n    uint width_in_tiles;\n    uint height_in_tiles;\n    Alloc tile_alloc;\n    Alloc bin_alloc;\n    Alloc ptcl_alloc;\n    Alloc pathseg_alloc;\n    Alloc anno_alloc;\n    Alloc trans_alloc;\n};\n\nlayout(binding = 0, std430) buffer Memory\n{\n    uint mem_offset;\n    uint mem_error;\n    uint memory[];\n} _96;\n\nlayout(binding = 1, std430) readonly buffer ConfigBuf\n{\n    Config conf;\n} _309;\n\nshared uint sh_tile_count[128];\nshared MallocResult sh_tile_alloc;\n\nbool touch_mem(Alloc alloc, uint offset)\n{\n    return true;\n}\n\nuint read_mem(Alloc alloc, uint offset)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return 0u;\n    }\n    uint v = _96.memory[offset];\n    return v;\n}\n\nAnnotatedTag Annotated_tag(Alloc a, AnnotatedRef ref)\n{\n    Alloc param = a;\n    uint param_1 = ref.offset >> uint(2);\n    uint tag_and_flags = read_mem(param, param_1);\n    return AnnotatedTag(tag_and_flags & 65535u, tag_and_flags >> uint(16));\n}\n\nAnnoEndClip AnnoEndClip_read(Alloc a, AnnoEndClipRef ref)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint raw0 = read_mem(param, param_1);\n    Alloc param_2 = a;\n    uint param_3 = ix + 1u;\n    uint raw1 = read_mem(param_2, param_3);\n    Alloc param_4 = a;\n    uint param_5 = ix + 2u;\n    uint raw2 = read_mem(param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 3u;\n    uint raw3 = read_mem(param_6, param_7);\n    AnnoEndClip s;\n    s.bbox = vec4(uintBitsToFloat(raw0), uintBitsToFloat(raw1), uintBitsToFloat(raw2), uintBitsToFloat(raw3));\n    return s;\n}\n\nAnnoEndClip Annotated_EndClip_read(Alloc a, AnnotatedRef ref)\n{\n    Alloc param = a;\n    AnnoEndClipRef param_1 = AnnoEndClipRef(ref.offset + 4u);\n    return AnnoEndClip_read(param, param_1);\n}\n\nAlloc new_alloc(uint offset, uint size)\n{\n    Alloc a;\n    a.offset = offset;\n    return a;\n}\n\nMallocResult malloc(uint size)\n{\n    MallocResult r;\n    r.failed = false;\n    uint _102 = atomicAdd(_96.mem_offset, size);\n    uint offset = _102;\n    uint param = offset;\n    uint param_1 = size;\n    r.alloc = new_alloc(param, param_1);\n    if ((offset + size) > uint(int(uint(_96.memory.length())) * 4))\n    {\n        r.failed = true;\n        uint _123 = atomicMax(_96.mem_error, 1u);\n        return r;\n    }\n    return r;\n}\n\nAlloc slice_mem(Alloc a, uint offset, uint size)\n{\n    uint param = a.offset + offset;\n    uint param_1 = size;\n    return new_alloc(param, param_1);\n}\n\nvoid write_mem(Alloc alloc, uint offset, uint val)\n{\n    Alloc param = alloc;\n    uint param_1 = offset;\n    if (!touch_mem(param, param_1))\n    {\n        return;\n    }\n    _96.memory[offset] = val;\n}\n\nvoid Path_write(Alloc a, PathRef ref, Path s)\n{\n    uint ix = ref.offset >> uint(2);\n    Alloc param = a;\n    uint param_1 = ix + 0u;\n    uint param_2 = s.bbox.x | (s.bbox.y << uint(16));\n    write_mem(param, param_1, param_2);\n    Alloc param_3 = a;\n    uint param_4 = ix + 1u;\n    uint param_5 = s.bbox.z | (s.bbox.w << uint(16));\n    write_mem(param_3, param_4, param_5);\n    Alloc param_6 = a;\n    uint param_7 = ix + 2u;\n    uint param_8 = s.tiles.offset;\n    write_mem(param_6, param_7, param_8);\n}\n\nvoid main()\n{\n    if (_96.mem_error != 0u)\n    {\n        return;\n    }\n    uint th_ix = gl_LocalInvocationID.x;\n    uint element_ix = gl_GlobalInvocationID.x;\n    PathRef path_ref = PathRef(_309.conf.tile_alloc.offset + (element_ix * 12u));\n    AnnotatedRef ref = AnnotatedRef(_309.conf.anno_alloc.offset + (element_ix * 32u));\n    uint tag = 0u;\n    if (element_ix < _309.conf.n_elements)\n    {\n        Alloc param;\n        param.offset = _309.conf.anno_alloc.offset;\n        AnnotatedRef param_1 = ref;\n        tag = Annotated_tag(param, param_1).tag;\n    }\n    int x0 = 0;\n    int y0 = 0;\n    int x1 = 0;\n    int y1 = 0;\n    switch (tag)\n    {\n        case 1u:\n        case 2u:\n        case 3u:\n        case 4u:\n        {\n            Alloc param_2;\n            param_2.offset = _309.conf.anno_alloc.offset;\n            AnnotatedRef param_3 = ref;\n            AnnoEndClip clip = Annotated_EndClip_read(param_2, param_3);\n            x0 = int(floor(clip.bbox.x * 0.03125));\n            y0 = int(floor(clip.bbox.y * 0.03125));\n            x1 = int(ceil(clip.bbox.z * 0.03125));\n            y1 = int(ceil(clip.bbox.w * 0.03125));\n            break;\n        }\n    }\n    x0 = clamp(x0, 0, int(_309.conf.width_in_tiles));\n    y0 = clamp(y0, 0, int(_309.conf.height_in_tiles));\n    x1 = clamp(x1, 0, int(_309.conf.width_in_tiles));\n    y1 = clamp(y1, 0, int(_309.conf.height_in_tiles));\n    Path path;\n    path.bbox = uvec4(uint(x0), uint(y0), uint(x1), uint(y1));\n    uint tile_count = uint((x1 - x0) * (y1 - y0));\n    if (tag == 4u)\n    {\n        tile_count = 0u;\n    }\n    sh_tile_count[th_ix] = tile_count;\n    uint total_tile_count = tile_count;\n    for (uint i = 0u; i < 7u; i++)\n    {\n        barrier();\n        if (th_ix >= uint(1 << int(i)))\n        {\n            total_tile_count += sh_tile_count[th_ix - uint(1 << int(i))];\n        }\n        barrier();\n        sh_tile_count[th_ix] = total_tile_count;\n    }\n    if (th_ix == 127u)\n    {\n        uint param_4 = total_tile_count * 8u;\n        MallocResult _482 = malloc(param_4);\n        sh_tile_alloc = _482;\n    }\n    barrier();\n    MallocResult alloc_start = sh_tile_alloc;\n    if (alloc_start.failed)\n    {\n        return;\n    }\n    if (element_ix < _309.conf.n_elements)\n    {\n        uint _499;\n        if (th_ix > 0u)\n        {\n            _499 = sh_tile_count[th_ix - 1u];\n        }\n        else\n        {\n            _499 = 0u;\n        }\n        uint tile_subix = _499;\n        Alloc param_5 = alloc_start.alloc;\n        uint param_6 = 8u * tile_subix;\n        uint param_7 = 8u * tile_count;\n        Alloc tiles_alloc = slice_mem(param_5, param_6, param_7);\n        path.tiles = TileRef(tiles_alloc.offset);\n        Alloc param_8;\n        param_8.offset = _309.conf.tile_alloc.offset;\n        PathRef param_9 = path_ref;\n        Path param_10 = path;\n        Path_write(param_8, param_9, param_10);\n    }\n    uint total_count = sh_tile_count[127] * 2u;\n    uint start_ix = alloc_start.alloc.offset >> uint(2);\n    for (uint i_1 = th_ix; i_1 < total_count; i_1 += 128u)\n    {\n        Alloc param_11 = alloc_start.alloc;\n        uint param_12 = start_ix + i_1;\n        uint param_13 = 0u;\n        write_mem(param_11, param_12, param_13);\n    }\n}\n\n",
	}
)
